let d = null, v = null;
window.torrentCallbacks = {};
async function f(o) {
  try {
    const i = document.getElementById(o);
    if (!window.WebTorrent) throw new Error("WebTorrent not loaded in window");
    d || (d = new window.WebTorrent()), i && (i.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: center; height: 400px; color: white;">
                    <span>Pronto para reproduzir torrents</span>
                </div>
            `);
  } catch (i) {
    throw console.error("Erro ao inicializar WebTorrent:", i), i;
  }
}
async function m(o, i, s, n) {
  try {
    d || (d = new window.WebTorrent()), v && (v.destroy(), v = null);
    const e = document.querySelector(i);
    if (!e) throw new Error("Container não encontrado");
    e.innerHTML = `
            <div style="display: flex; align-items: center; justify-content: center; width: 100%; height: 400px; background: #000; color: #fff;">
                <div style="text-align: center;">
                    <div style="margin-bottom: 10px;">Carregando torrent...</div>
                    <div id="progress-${o}" style="font-size: 14px;">0%</div>
                </div>
            </div>
        `, console.log("Adicionando torrent..."), d.add(s, (t) => {
      console.log("Torrent adicionado:", t.name);
      const u = t.files.filter(
        (r) => /\.(mp4|mkv|webm|avi|mov|m4v|flv|wmv)$/i.test(r.name)
      );
      if (u.length === 0) {
        const r = "Nenhum arquivo de vídeo encontrado no torrent.";
        e.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: center; height: 400px; color: red; background: #000;">
                        <div style="text-align: center; padding: 20px;">
                            <div>${r}</div>
                            <div style="margin-top: 10px; font-size: 12px;">Arquivos encontrados: ${t.files.map((a) => a.name).join(", ")}</div>
                        </div>
                    </div>
                `, n && n.invokeMethodAsync("OnTorrentErrorCallback", r);
        return;
      }
      const c = u.reduce(
        (r, a) => r.length > a.length ? r : a
      );
      console.log("Arquivo de vídeo selecionado:", c.name, `(${w(c.length)})`), e.innerHTML = `
                <video 
                    controls 
                    playsinline 
                    style="width:100%; height:100%; background:#000;"
                    preload="metadata">
                    Seu navegador não suporta o elemento de vídeo.
                </video>
            `;
      const g = e.querySelector("video");
      if (!g) {
        n && n.invokeMethodAsync("OnTorrentErrorCallback", "Erro ao criar elemento de vídeo");
        return;
      }
      try {
        c.renderTo(g, {
          autoplay: !1,
          controls: !0
        }, (r, a) => {
          if (r) {
            console.error("Erro ao renderizar vídeo:", r);
            const l = `Erro ao reproduzir vídeo: ${r.message}`;
            e.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: center; height: 400px; color: red; background: #000;">
                    <div style="text-align: center; padding: 20px;">${l}</div>
                </div>
            `, n && n.invokeMethodAsync("OnTorrentErrorCallback", l);
            return;
          }
          a instanceof HTMLVideoElement && (a.muted = !1), console.log("Vídeo renderizado com sucesso"), n && n.invokeMethodAsync("OnTorrentReadyCallback");
        });
      } catch (r) {
        console.error("Erro no renderTo:", r);
        const a = `Erro ao inicializar reprodução: ${r}`;
        n && n.invokeMethodAsync("OnTorrentErrorCallback", a);
      }
      t.on("download", () => {
        const r = Math.floor(t.progress * 100), a = w(t.downloadSpeed), l = w(t.downloaded), y = w(t.length), h = document.getElementById(`progress-${o}`);
        h && (h.textContent = `${r}% - ${l}/${y} - ${a}/s`), n && n.invokeMethodAsync("OnTorrentProgressUpdate", r);
      }), t.on("done", () => {
        console.log("Download completo");
        const r = document.getElementById(`progress-${o}`);
        r && (r.textContent = "Download completo");
      }), t.on("error", (r) => {
        console.error("Erro no torrent:", r);
        const a = r instanceof Error ? r.message : r;
        n && n.invokeMethodAsync("OnTorrentErrorCallback", a);
      }), v = t;
    });
  } catch (e) {
    console.error("Erro em startDownload:", e);
    const t = e instanceof Error ? e.message : "Erro desconhecido";
    throw n && n.invokeMethodAsync("OnTorrentErrorCallback", t), e;
  }
}
async function p(o, i, s) {
  return new Promise((n, e) => {
    var g;
    const t = document.getElementById(`torrent-file-${o}`);
    if (!t) {
      const r = "Input de arquivo não encontrado";
      s && s.invokeMethodAsync("OnTorrentErrorCallback", r), e(new Error(r));
      return;
    }
    const u = (g = t.files) == null ? void 0 : g[0];
    if (!u) {
      const r = "Nenhum arquivo selecionado";
      s && s.invokeMethodAsync("OnTorrentErrorCallback", r), e(new Error(r));
      return;
    }
    if (!u.name.endsWith(".torrent")) {
      const r = "Arquivo deve ter extensão .torrent";
      s && s.invokeMethodAsync("OnTorrentErrorCallback", r), e(new Error(r));
      return;
    }
    const c = new FileReader();
    c.onload = async (r) => {
      var a;
      try {
        const l = (a = r.target) == null ? void 0 : a.result;
        if (!l) {
          const y = "Erro ao ler arquivo";
          s && s.invokeMethodAsync("OnTorrentErrorCallback", y), e(new Error(y));
          return;
        }
        await m(
          o,
          i,
          l,
          s
        ), n();
      } catch (l) {
        e(l);
      }
    }, c.onerror = () => {
      const r = "Erro ao ler arquivo .torrent";
      s && s.invokeMethodAsync("OnTorrentErrorCallback", r), e(new Error(r));
    }, c.readAsArrayBuffer(u);
  });
}
async function E() {
  try {
    v && (v.destroy(), v = null), d && await new Promise((o) => {
      d.destroy(() => {
        d = new window.WebTorrent(), o();
      });
    });
  } catch (o) {
    throw console.error("Erro ao parar download:", o), o;
  }
}
window.handleTorrentFile = async function(o) {
  try {
    const i = window.torrentCallbacks[o];
    await p(o, `#${o}`, i);
  } catch (i) {
    console.error("Erro ao carregar arquivo torrent:", i);
  }
};
function w(o) {
  if (o === 0) return "0 B";
  const i = 1024, s = ["B", "KB", "MB", "GB", "TB"], n = Math.floor(Math.log(o) / Math.log(i));
  return parseFloat((o / Math.pow(i, n)).toFixed(1)) + " " + s[n];
}
export {
  f as initTorrentPlayer,
  m as startDownload,
  p as startDownloadFromFile,
  E as stopDownload
};

let n = null, r = null;
async function w(t) {
  try {
    n = new WebTorrent(), t.textContent = "Ready to play";
  } catch (c) {
    throw c;
  }
}
async function y(t, c, i) {
  try {
    n || (n = new WebTorrent()), r && (r.destroy(), r = null);
    const a = document.querySelector(c);
    a.innerHTML = "";
    const e = document.createElement("video");
    e.style.width = "100%", e.style.height = "100%", e.style.backgroundColor = "#000", e.controls = !0, e.autoplay = !0, a.appendChild(e), r = n.add(i, {
      announce: [
        "wss://tracker.btorrent.xyz",
        "wss://tracker.openwebtorrent.com",
        "wss://tracker.fastcast.nz"
      ]
    }), r.on("ready", () => {
      const o = r.files.find((l) => /\.(mp4|mkv|webm)$/i.test(l.name));
      if (!o)
        throw new Error("No video file found");
      o.getBlobURL((l, d) => {
        if (l) throw l;
        e.src = d;
        const s = e.play();
        s && s.catch(() => {
          console.log("Autoplay prevented, trying again..."), o.createReadStream().pipe(e);
        });
      }), o.select();
    }), r.on("download", () => {
      const o = Math.floor(r.progress * 100);
      t.textContent = `Downloading: ${o}%`, e.paused && e.play().catch(console.error);
    }), r.on("error", (o) => {
      throw console.error("Torrent error:", o), o;
    });
  } catch (a) {
    throw console.error("Error in startDownload:", a), a;
  }
}
async function p() {
  try {
    r && (r.destroy(), r = null), n && await new Promise((t) => {
      n.destroy(() => {
        n = new WebTorrent(), t();
      });
    });
  } catch (t) {
    throw console.error("Error stopping download:", t), t;
  }
}
export {
  w as initTorrentPlayer,
  y as startDownload,
  p as stopDownload
};

var Ct = Object.defineProperty;
var Et = (e, t, i) => t in e ? Ct(e, t, { enumerable: !0, configurable: !0, writable: !0, value: i }) : e[t] = i;
var f = (e, t, i) => Et(e, typeof t != "symbol" ? t + "" : t, i);
function At(e, t) {
  if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
}
function je(e, t) {
  for (var i = 0; i < t.length; i++) {
    var n = t[i];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
  }
}
function St(e, t, i) {
  return t && je(e.prototype, t), i && je(e, i), e;
}
function Pt(e, t, i) {
  return t in e ? Object.defineProperty(e, t, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = i, e;
}
function qe(e, t) {
  var i = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(s) {
      return Object.getOwnPropertyDescriptor(e, s).enumerable;
    })), i.push.apply(i, n);
  }
  return i;
}
function Ve(e) {
  for (var t = 1; t < arguments.length; t++) {
    var i = arguments[t] != null ? arguments[t] : {};
    t % 2 ? qe(Object(i), !0).forEach(function(n) {
      Pt(e, n, i[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : qe(Object(i)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(i, n));
    });
  }
  return e;
}
var Ue = { addCSS: !0, thumbWidth: 15, watch: !0 };
function Mt(e, t) {
  return (function() {
    return Array.from(document.querySelectorAll(t)).includes(this);
  }).call(e, t);
}
function xt(e, t) {
  if (e && t) {
    var i = new Event(t, { bubbles: !0 });
    e.dispatchEvent(i);
  }
}
var ae = function(e) {
  return e != null ? e.constructor : null;
}, $e = function(e, t) {
  return !!(e && t && e instanceof t);
}, Ke = function(e) {
  return e == null;
}, Ye = function(e) {
  return ae(e) === Object;
}, Lt = function(e) {
  return ae(e) === Number && !Number.isNaN(e);
}, Xe = function(e) {
  return ae(e) === String;
}, $t = function(e) {
  return ae(e) === Boolean;
}, Nt = function(e) {
  return ae(e) === Function;
}, Qe = function(e) {
  return Array.isArray(e);
}, Ge = function(e) {
  return $e(e, NodeList);
}, It = function(e) {
  return $e(e, Element);
}, Ot = function(e) {
  return $e(e, Event);
}, _t = function(e) {
  return Ke(e) || (Xe(e) || Qe(e) || Ge(e)) && !e.length || Ye(e) && !Object.keys(e).length;
}, q = { nullOrUndefined: Ke, object: Ye, number: Lt, string: Xe, boolean: $t, function: Nt, array: Qe, nodeList: Ge, element: It, event: Ot, empty: _t };
function Dt(e) {
  var t = "".concat(e).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
  return t ? Math.max(0, (t[1] ? t[1].length : 0) - (t[2] ? +t[2] : 0)) : 0;
}
function Ht(e, t) {
  if (1 > t) {
    var i = Dt(t);
    return parseFloat(e.toFixed(i));
  }
  return Math.round(e / t) * t;
}
var jt = function() {
  function e(t, i) {
    At(this, e), q.element(t) ? this.element = t : q.string(t) && (this.element = document.querySelector(t)), q.element(this.element) && q.empty(this.element.rangeTouch) && (this.config = Ve({}, Ue, {}, i), this.init());
  }
  return St(e, [{ key: "init", value: function() {
    e.enabled && (this.config.addCSS && (this.element.style.userSelect = "none", this.element.style.webKitUserSelect = "none", this.element.style.touchAction = "manipulation"), this.listeners(!0), this.element.rangeTouch = this);
  } }, { key: "destroy", value: function() {
    e.enabled && (this.config.addCSS && (this.element.style.userSelect = "", this.element.style.webKitUserSelect = "", this.element.style.touchAction = ""), this.listeners(!1), this.element.rangeTouch = null);
  } }, { key: "listeners", value: function(t) {
    var i = this, n = t ? "addEventListener" : "removeEventListener";
    ["touchstart", "touchmove", "touchend"].forEach(function(s) {
      i.element[n](s, function(a) {
        return i.set(a);
      }, !1);
    });
  } }, { key: "get", value: function(t) {
    if (!e.enabled || !q.event(t)) return null;
    var i, n = t.target, s = t.changedTouches[0], a = parseFloat(n.getAttribute("min")) || 0, o = parseFloat(n.getAttribute("max")) || 100, l = parseFloat(n.getAttribute("step")) || 1, c = n.getBoundingClientRect(), u = 100 / c.width * (this.config.thumbWidth / 2) / 100;
    return 0 > (i = 100 / c.width * (s.clientX - c.left)) ? i = 0 : 100 < i && (i = 100), 50 > i ? i -= (100 - 2 * i) * u : 50 < i && (i += 2 * (i - 50) * u), a + Ht(i / 100 * (o - a), l);
  } }, { key: "set", value: function(t) {
    e.enabled && q.event(t) && !t.target.disabled && (t.preventDefault(), t.target.value = this.get(t), xt(t.target, t.type === "touchend" ? "change" : "input"));
  } }], [{ key: "setup", value: function(t) {
    var i = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : {}, n = null;
    if (q.empty(t) || q.string(t) ? n = Array.from(document.querySelectorAll(q.string(t) ? t : 'input[type="range"]')) : q.element(t) ? n = [t] : q.nodeList(t) ? n = Array.from(t) : q.array(t) && (n = t.filter(q.element)), q.empty(n)) return null;
    var s = Ve({}, Ue, {}, i);
    if (q.string(t) && s.watch) {
      var a = new MutationObserver(function(o) {
        Array.from(o).forEach(function(l) {
          Array.from(l.addedNodes).forEach(function(c) {
            q.element(c) && Mt(c, t) && new e(c, s);
          });
        });
      });
      a.observe(document.body, { childList: !0, subtree: !0 });
    }
    return n.map(function(o) {
      return new e(o, i);
    });
  } }, { key: "enabled", get: function() {
    return "ontouchstart" in document.documentElement;
  } }]), e;
}();
const oe = (e) => e !== null && typeof e < "u" ? e.constructor : null, K = (e, t) => !!(e && t && e instanceof t), Ne = (e) => e === null || typeof e > "u", Je = (e) => oe(e) === Object, qt = (e) => oe(e) === Number && !Number.isNaN(e), ye = (e) => oe(e) === String, Vt = (e) => oe(e) === Boolean, Ze = (e) => typeof e == "function", et = (e) => Array.isArray(e), Ut = (e) => K(e, WeakMap), tt = (e) => K(e, NodeList), Ft = (e) => oe(e) === Text, Rt = (e) => K(e, Event), Wt = (e) => K(e, KeyboardEvent), Bt = (e) => K(e, window.TextTrackCue) || K(e, window.VTTCue), zt = (e) => K(e, TextTrack) || !Ne(e) && ye(e.kind), Kt = (e) => K(e, Promise) && Ze(e.then);
function Yt(e) {
  return e !== null && typeof e == "object" && e.nodeType === 1 && typeof e.style == "object" && typeof e.ownerDocument == "object";
}
function it(e) {
  return Ne(e) || (ye(e) || et(e) || tt(e)) && !e.length || Je(e) && !Object.keys(e).length;
}
function Xt(e) {
  if (K(e, window.URL))
    return !0;
  if (!ye(e))
    return !1;
  let t = e;
  (!e.startsWith("http://") || !e.startsWith("https://")) && (t = `http://${e}`);
  try {
    return !it(new URL(t).hostname);
  } catch {
    return !1;
  }
}
const r = {
  nullOrUndefined: Ne,
  object: Je,
  number: qt,
  string: ye,
  boolean: Vt,
  function: Ze,
  array: et,
  weakMap: Ut,
  nodeList: tt,
  element: Yt,
  textNode: Ft,
  event: Rt,
  keyboardEvent: Wt,
  cue: Bt,
  track: zt,
  promise: Kt,
  url: Xt,
  empty: it
}, Ee = (() => {
  const e = document.createElement("span"), t = {
    WebkitTransition: "webkitTransitionEnd",
    MozTransition: "transitionend",
    OTransition: "oTransitionEnd otransitionend",
    transition: "transitionend"
  }, i = Object.keys(t).find((n) => e.style[n] !== void 0);
  return r.string(i) ? t[i] : !1;
})();
function st(e, t) {
  setTimeout(() => {
    try {
      e.hidden = !0, e.offsetHeight, e.hidden = !1;
    } catch {
    }
  }, t);
}
function Qt(e) {
  return JSON.parse(JSON.stringify(e));
}
function nt(e, t) {
  return t.split(".").reduce((i, n) => i && i[n], e);
}
function I(e = {}, ...t) {
  if (!t.length)
    return e;
  const i = t.shift();
  return r.object(i) ? (Object.keys(i).forEach((n) => {
    r.object(i[n]) ? (Object.keys(e).includes(n) || Object.assign(e, { [n]: {} }), I(e[n], i[n])) : Object.assign(e, { [n]: i[n] });
  }), I(e, ...t)) : e;
}
function rt(e, t) {
  const i = e.length ? e : [e];
  Array.from(i).reverse().forEach((n, s) => {
    const a = s > 0 ? t.cloneNode(!0) : t, o = n.parentNode, l = n.nextSibling;
    a.appendChild(n), l ? o.insertBefore(a, l) : o.appendChild(a);
  });
}
function Ae(e, t) {
  !r.element(e) || r.empty(t) || Object.entries(t).filter(([, i]) => !r.nullOrUndefined(i)).forEach(([i, n]) => e.setAttribute(i, n));
}
function v(e, t, i) {
  const n = document.createElement(e);
  return r.object(t) && Ae(n, t), r.string(i) && (n.textContent = i), n;
}
function Gt(e, t) {
  !r.element(e) || !r.element(t) || t.parentNode.insertBefore(e, t.nextSibling);
}
function Fe(e, t, i, n) {
  r.element(t) && t.appendChild(v(e, i, n));
}
function B(e) {
  if (r.nodeList(e) || r.array(e)) {
    Array.from(e).forEach(B);
    return;
  }
  !r.element(e) || !r.element(e.parentNode) || e.parentNode.removeChild(e);
}
function ue(e) {
  if (!r.element(e)) return;
  let { length: t } = e.childNodes;
  for (; t > 0; )
    e.removeChild(e.lastChild), t -= 1;
}
function me(e, t) {
  return !r.element(t) || !r.element(t.parentNode) || !r.element(e) ? null : (t.parentNode.replaceChild(e, t), e);
}
function R(e, t) {
  if (!r.string(e) || r.empty(e)) return {};
  const i = {}, n = I({}, t);
  return e.split(",").forEach((s) => {
    const a = s.trim(), o = a.replace(".", ""), c = a.replace(/[[\]]/g, "").split("="), [u] = c, m = c.length > 1 ? c[1].replace(/["']/g, "") : "";
    switch (a.charAt(0)) {
      case ".":
        r.string(n.class) ? i.class = `${n.class} ${o}` : i.class = o;
        break;
      case "#":
        i.id = a.replace("#", "");
        break;
      case "[":
        i[u] = m;
        break;
    }
  }), I(n, i);
}
function Q(e, t) {
  if (!r.element(e)) return;
  let i = t;
  r.boolean(i) || (i = !e.hidden), e.hidden = i;
}
function P(e, t, i) {
  if (r.nodeList(e))
    return Array.from(e).map((n) => P(n, t, i));
  if (r.element(e)) {
    let n = "toggle";
    return typeof i < "u" && (n = i ? "add" : "remove"), e.classList[n](t), e.classList.contains(t);
  }
  return !1;
}
function pe(e, t) {
  return r.element(e) && e.classList.contains(t);
}
function G(e, t) {
  const { prototype: i } = Element;
  function n() {
    return Array.from(document.querySelectorAll(t)).includes(this);
  }
  return (i.matches || i.webkitMatchesSelector || i.mozMatchesSelector || i.msMatchesSelector || n).call(e, t);
}
function Jt(e, t) {
  const { prototype: i } = Element;
  function n() {
    let a = this;
    do {
      if (G.matches(a, t)) return a;
      a = a.parentElement || a.parentNode;
    } while (a !== null && a.nodeType === 1);
    return null;
  }
  return (i.closest || n).call(e, t);
}
function ie(e) {
  return this.elements.container.querySelectorAll(e);
}
function _(e) {
  return this.elements.container.querySelector(e);
}
function ve(e = null, t = !1) {
  r.element(e) && e.focus({ preventScroll: !0, focusVisible: t });
}
const Re = {
  "audio/ogg": "vorbis",
  "audio/wav": "1",
  "video/webm": "vp8, vorbis",
  "video/mp4": "avc1.42E01E, mp4a.40.2",
  "video/ogg": "theora"
}, O = {
  // Basic support
  audio: "canPlayType" in document.createElement("audio"),
  video: "canPlayType" in document.createElement("video"),
  // Check for support
  // Basic functionality vs full UI
  check(e, t) {
    const i = O[e] || t !== "html5", n = i && O.rangeInput;
    return {
      api: i,
      ui: n
    };
  },
  // Picture-in-picture support
  pip: document.pictureInPictureEnabled && !v("video").disablePictureInPicture,
  // Airplay support
  // Safari only currently
  airplay: r.function(window.WebKitPlaybackTargetAvailabilityEvent),
  // Inline playback support
  // https://webkit.org/blog/6784/new-video-policies-for-ios/
  playsinline: "playsInline" in document.createElement("video"),
  // Check for mime type support against a player instance
  // Credits: http://diveintohtml5.info/everything.html
  // Related: http://www.leanbackplayer.com/test/h5mt.html
  mime(e) {
    if (r.empty(e))
      return !1;
    const [t] = e.split("/");
    let i = e;
    if (!this.isHTML5 || t !== this.type)
      return !1;
    Object.keys(Re).includes(i) && (i += `; codecs="${Re[e]}"`);
    try {
      return !!(i && this.media.canPlayType(i).replace(/no/, ""));
    } catch {
      return !1;
    }
  },
  // Check for textTracks support
  textTracks: "textTracks" in document.createElement("video"),
  // <input type="range"> Sliders
  rangeInput: (() => {
    const e = document.createElement("input");
    return e.type = "range", e.type === "range";
  })(),
  // Touch
  // NOTE: Remember a device can be mouse + touch enabled so we check on first touch event
  touch: "ontouchstart" in document.documentElement,
  // Detect transitions support
  transitions: Ee !== !1,
  // Reduced motion iOS & MacOS setting
  // https://webkit.org/blog/7551/responsive-design-for-motion/
  reducedMotion: "matchMedia" in window && window.matchMedia("(prefers-reduced-motion)").matches
}, Zt = (() => {
  let e = !1;
  try {
    const t = Object.defineProperty({}, "passive", {
      get() {
        return e = !0, null;
      }
    });
    window.addEventListener("test", null, t), window.removeEventListener("test", null, t);
  } catch {
  }
  return e;
})();
function se(e, t, i, n = !1, s = !0, a = !1) {
  if (!e || !("addEventListener" in e) || r.empty(t) || !r.function(i))
    return;
  const o = t.split(" ");
  let l = a;
  Zt && (l = {
    // Whether the listener can be passive (i.e. default never prevented)
    passive: s,
    // Whether the listener is a capturing listener or not
    capture: a
  }), o.forEach((c) => {
    this && this.eventListeners && n && this.eventListeners.push({ element: e, type: c, callback: i, options: l }), e[n ? "addEventListener" : "removeEventListener"](c, i, l);
  });
}
function E(e, t = "", i, n = !0, s = !1) {
  se.call(this, e, t, i, !0, n, s);
}
function be(e, t = "", i, n = !0, s = !1) {
  se.call(this, e, t, i, !1, n, s);
}
function Ie(e, t = "", i, n = !0, s = !1) {
  const a = (...o) => {
    be(e, t, a, n, s), i.apply(this, o);
  };
  se.call(this, e, t, a, !0, n, s);
}
function k(e, t = "", i = !1, n = {}) {
  if (!r.element(e) || r.empty(t))
    return;
  const s = new CustomEvent(t, {
    bubbles: i,
    detail: { ...n, plyr: this }
  });
  e.dispatchEvent(s);
}
function ei() {
  this && this.eventListeners && (this.eventListeners.forEach((e) => {
    const { element: t, type: i, callback: n, options: s } = e;
    t.removeEventListener(i, n, s);
  }), this.eventListeners = []);
}
function ti() {
  return new Promise(
    (e) => this.ready ? setTimeout(e, 0) : E.call(this, this.elements.container, "ready", e)
  ).then(() => {
  });
}
function W(e) {
  r.promise(e) && e.then(null, () => {
  });
}
function Se(e) {
  return r.array(e) ? e.filter((t, i) => e.indexOf(t) === i) : e;
}
function at(e, t) {
  return !r.array(e) || !e.length ? null : e.reduce((i, n) => Math.abs(n - t) < Math.abs(i - t) ? n : i);
}
function ot(e) {
  return !window || !window.CSS ? !1 : window.CSS.supports(e);
}
const We = [
  [1, 1],
  [4, 3],
  [3, 4],
  [5, 4],
  [4, 5],
  [3, 2],
  [2, 3],
  [16, 10],
  [10, 16],
  [16, 9],
  [9, 16],
  [21, 9],
  [9, 21],
  [32, 9],
  [9, 32]
].reduce((e, [t, i]) => ({ ...e, [t / i]: [t, i] }), {});
function lt(e) {
  return !r.array(e) && (!r.string(e) || !e.includes(":")) ? !1 : (r.array(e) ? e : e.split(":")).map(Number).every(r.number);
}
function fe(e) {
  if (!r.array(e) || !e.every(r.number))
    return null;
  const [t, i] = e, n = (a, o) => o === 0 ? a : n(o, a % o), s = n(t, i);
  return [t / s, i / s];
}
function Oe(e) {
  const t = (n) => lt(n) ? n.split(":").map(Number) : null;
  let i = t(e);
  if (i === null && (i = t(this.config.ratio)), i === null && !r.empty(this.embed) && r.array(this.embed.ratio) && ({ ratio: i } = this.embed), i === null && this.isHTML5) {
    const { videoWidth: n, videoHeight: s } = this.media;
    i = [n, s];
  }
  return fe(i);
}
function J(e) {
  if (!this.isVideo)
    return {};
  const { wrapper: t } = this.elements, i = Oe.call(this, e);
  if (!r.array(i))
    return {};
  const [n, s] = fe(i), a = ot(`aspect-ratio: ${n}/${s}`), o = 100 / n * s;
  if (a ? t.style.aspectRatio = `${n}/${s}` : t.style.paddingBottom = `${o}%`, this.isVimeo && !this.config.vimeo.premium && this.supported.ui) {
    const l = 100 / this.media.offsetWidth * Number.parseInt(window.getComputedStyle(this.media).paddingBottom, 10), c = (l - o) / (l / 50);
    this.fullscreen.active ? t.style.paddingBottom = null : this.media.style.transform = `translateY(-${c}%)`;
  } else this.isHTML5 && t.classList.add(this.config.classNames.videoFixedRatio);
  return { padding: o, ratio: i };
}
function ct(e, t, i = 0.05) {
  const n = e / t, s = at(Object.keys(We), n);
  return Math.abs(s - n) <= i ? We[s] : [e, t];
}
function ii() {
  const e = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0), t = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
  return [e, t];
}
const X = {
  getSources() {
    return this.isHTML5 ? Array.from(this.media.querySelectorAll("source")).filter((t) => {
      const i = t.getAttribute("type");
      return r.empty(i) ? !0 : O.mime.call(this, i);
    }) : [];
  },
  // Get quality levels
  getQualityOptions() {
    return this.config.quality.forced ? this.config.quality.options : X.getSources.call(this).map((e) => Number(e.getAttribute("size"))).filter(Boolean);
  },
  setup() {
    if (!this.isHTML5)
      return;
    const e = this;
    e.options.speed = e.config.speed.options, r.empty(this.config.ratio) || J.call(e), Object.defineProperty(e.media, "quality", {
      get() {
        const i = X.getSources.call(e).find((n) => n.getAttribute("src") === e.source);
        return i && Number(i.getAttribute("size"));
      },
      set(t) {
        if (e.quality !== t) {
          if (e.config.quality.forced && r.function(e.config.quality.onChange))
            e.config.quality.onChange(t);
          else {
            const n = X.getSources.call(e).find((u) => Number(u.getAttribute("size")) === t);
            if (!n)
              return;
            const { currentTime: s, paused: a, preload: o, readyState: l, playbackRate: c } = e.media;
            e.media.src = n.getAttribute("src"), (o !== "none" || l) && (e.once("loadedmetadata", () => {
              e.speed = c, e.currentTime = s, a || W(e.play());
            }), e.media.load());
          }
          k.call(e, e.media, "qualitychange", !1, {
            quality: t
          });
        }
      }
    });
  },
  // Cancel current network requests
  // See https://github.com/sampotts/plyr/issues/174
  cancelRequests() {
    this.isHTML5 && (B(X.getSources.call(this)), this.media.setAttribute("src", this.config.blankVideo), this.media.load(), this.debug.log("Cancelled network requests"));
  }
}, si = !!window.document.documentMode, ni = /Edge/.test(navigator.userAgent), ri = "WebkitAppearance" in document.documentElement.style && !/Edge/.test(navigator.userAgent), ai = navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1, oi = /iPad|iPhone|iPod/i.test(navigator.userAgent) && navigator.maxTouchPoints > 1, j = {
  isIE: si,
  isEdge: ni,
  isWebKit: ri,
  isIPadOS: ai,
  isIos: oi
};
function li(e) {
  return `${e}-${Math.floor(Math.random() * 1e4)}`;
}
function Pe(e, ...t) {
  return r.empty(e) ? e : e.toString().replace(/\{(\d+)\}/g, (i, n) => t[n].toString());
}
function ci(e, t) {
  return e === 0 || t === 0 || Number.isNaN(e) || Number.isNaN(t) ? 0 : (e / t * 100).toFixed(2);
}
function te(e = "", t = "", i = "") {
  return e.replace(new RegExp(t.toString().replace(/([.*+?^=!:${}()|[\]/\\])/g, "\\$1"), "g"), i.toString());
}
function ut(e = "") {
  return e.toString().replace(/\w\S*/g, (t) => t.charAt(0).toUpperCase() + t.slice(1).toLowerCase());
}
function ui(e = "") {
  let t = e.toString();
  return t = te(t, "-", " "), t = te(t, "_", " "), t = ut(t), te(t, " ", "");
}
function di(e = "") {
  let t = e.toString();
  return t = ui(t), t.charAt(0).toLowerCase() + t.slice(1);
}
function hi(e) {
  const t = document.createDocumentFragment(), i = document.createElement("div");
  return t.appendChild(i), i.innerHTML = e, t.firstChild.textContent;
}
function mi(e) {
  const t = document.createElement("div");
  return t.appendChild(e), t.innerHTML;
}
const Be = {
  pip: "PIP",
  airplay: "AirPlay",
  html5: "HTML5",
  vimeo: "Vimeo",
  youtube: "YouTube"
}, H = {
  get(e = "", t = {}) {
    if (r.empty(e) || r.empty(t))
      return "";
    let i = nt(t.i18n, e);
    if (r.empty(i))
      return Object.keys(Be).includes(e) ? Be[e] : "";
    const n = {
      "{seektime}": t.seekTime,
      "{title}": t.title
    };
    return Object.entries(n).forEach(([s, a]) => {
      i = te(i, s, a);
    }), i;
  }
};
class ne {
  constructor(t) {
    f(this, "get", (t) => {
      if (!ne.supported || !this.enabled)
        return null;
      const i = window.localStorage.getItem(this.key);
      if (r.empty(i)) return null;
      const n = JSON.parse(i);
      return r.string(t) && t.length ? n[t] : n;
    });
    f(this, "set", (t) => {
      if (!ne.supported || !this.enabled || !r.object(t))
        return;
      let i = this.get();
      r.empty(i) && (i = {}), I(i, t);
      try {
        window.localStorage.setItem(this.key, JSON.stringify(i));
      } catch {
      }
    });
    this.enabled = t.config.storage.enabled, this.key = t.config.storage.key;
  }
  // Check for actual support (see if we can use it)
  static get supported() {
    try {
      if (!("localStorage" in window)) return !1;
      const t = "___test";
      return window.localStorage.setItem(t, t), window.localStorage.removeItem(t), !0;
    } catch {
      return !1;
    }
  }
}
function le(e, t = "text", i = !1) {
  return new Promise((n, s) => {
    try {
      const a = new XMLHttpRequest();
      if (!("withCredentials" in a)) return;
      i && (a.withCredentials = !0), a.addEventListener("load", () => {
        if (t === "text")
          try {
            n(JSON.parse(a.responseText));
          } catch {
            n(a.responseText);
          }
        else
          n(a.response);
      }), a.addEventListener("error", () => {
        throw new Error(a.status);
      }), a.open("GET", e, !0), a.responseType = t, a.send();
    } catch (a) {
      s(a);
    }
  });
}
function dt(e, t) {
  if (!r.string(e))
    return;
  const i = "cache", n = r.string(t);
  let s = !1;
  const a = () => document.getElementById(t) !== null, o = (l, c) => {
    l.innerHTML = c, !(n && a()) && document.body.insertAdjacentElement("afterbegin", l);
  };
  if (!n || !a()) {
    const l = ne.supported, c = document.createElement("div");
    if (c.setAttribute("hidden", ""), n && c.setAttribute("id", t), l) {
      const u = window.localStorage.getItem(`${i}-${t}`);
      if (s = u !== null, s) {
        const m = JSON.parse(u);
        o(c, m.content);
      }
    }
    le(e).then((u) => {
      if (!r.empty(u)) {
        if (l)
          try {
            window.localStorage.setItem(
              `${i}-${t}`,
              JSON.stringify({
                content: u
              })
            );
          } catch {
          }
        o(c, u);
      }
    }).catch(() => {
    });
  }
}
const ht = (e) => Math.trunc(e / 60 / 60 % 60, 10), pi = (e) => Math.trunc(e / 60 % 60, 10), fi = (e) => Math.trunc(e % 60, 10);
function we(e = 0, t = !1, i = !1) {
  if (!r.number(e))
    return we(void 0, t, i);
  const n = (l) => `0${l}`.slice(-2);
  let s = ht(e);
  const a = pi(e), o = fi(e);
  return t || s > 0 ? s = `${s}:` : s = "", `${i && e > 0 ? "-" : ""}${s}${n(a)}:${n(o)}`;
}
const p = {
  // Get icon URL
  getIconUrl() {
    const e = new URL(this.config.iconUrl, window.location), t = window.location.host ? window.location.host : window.top.location.host, i = e.host !== t || j.isIE && !window.svg4everybody;
    return {
      url: this.config.iconUrl,
      cors: i
    };
  },
  // Find the UI controls
  findElements() {
    try {
      return this.elements.controls = _.call(this, this.config.selectors.controls.wrapper), this.elements.buttons = {
        play: ie.call(this, this.config.selectors.buttons.play),
        pause: _.call(this, this.config.selectors.buttons.pause),
        restart: _.call(this, this.config.selectors.buttons.restart),
        rewind: _.call(this, this.config.selectors.buttons.rewind),
        fastForward: _.call(this, this.config.selectors.buttons.fastForward),
        mute: _.call(this, this.config.selectors.buttons.mute),
        pip: _.call(this, this.config.selectors.buttons.pip),
        airplay: _.call(this, this.config.selectors.buttons.airplay),
        settings: _.call(this, this.config.selectors.buttons.settings),
        captions: _.call(this, this.config.selectors.buttons.captions),
        fullscreen: _.call(this, this.config.selectors.buttons.fullscreen)
      }, this.elements.progress = _.call(this, this.config.selectors.progress), this.elements.inputs = {
        seek: _.call(this, this.config.selectors.inputs.seek),
        volume: _.call(this, this.config.selectors.inputs.volume)
      }, this.elements.display = {
        buffer: _.call(this, this.config.selectors.display.buffer),
        currentTime: _.call(this, this.config.selectors.display.currentTime),
        duration: _.call(this, this.config.selectors.display.duration)
      }, r.element(this.elements.progress) && (this.elements.display.seekTooltip = this.elements.progress.querySelector(`.${this.config.classNames.tooltip}`)), !0;
    } catch (e) {
      return this.debug.warn("It looks like there is a problem with your custom controls HTML", e), this.toggleNativeControls(!0), !1;
    }
  },
  // Create <svg> icon
  createIcon(e, t) {
    const i = "http://www.w3.org/2000/svg", n = p.getIconUrl.call(this), s = `${n.cors ? "" : n.url}#${this.config.iconPrefix}`, a = document.createElementNS(i, "svg");
    Ae(
      a,
      I(t, {
        "aria-hidden": "true",
        focusable: "false"
      })
    );
    const o = document.createElementNS(i, "use"), l = `${s}-${e}`;
    return "href" in o && o.setAttributeNS("http://www.w3.org/1999/xlink", "href", l), o.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", l), a.appendChild(o), a;
  },
  // Create hidden text label
  createLabel(e, t = {}) {
    const i = H.get(e, this.config), n = { ...t, class: [t.class, this.config.classNames.hidden].filter(Boolean).join(" ") };
    return v("span", n, i);
  },
  // Create a badge
  createBadge(e) {
    if (r.empty(e))
      return null;
    const t = v("span", {
      class: this.config.classNames.menu.value
    });
    return t.appendChild(
      v(
        "span",
        {
          class: this.config.classNames.menu.badge
        },
        e
      )
    ), t;
  },
  // Create a <button>
  createButton(e, t) {
    const i = I({}, t);
    let n = di(e);
    const s = {
      element: "button",
      toggle: !1,
      label: null,
      icon: null,
      labelPressed: null,
      iconPressed: null
    };
    switch (["element", "icon", "label"].forEach((o) => {
      Object.keys(i).includes(o) && (s[o] = i[o], delete i[o]);
    }), s.element === "button" && !Object.keys(i).includes("type") && (i.type = "button"), Object.keys(i).includes("class") ? i.class.split(" ").includes(this.config.classNames.control) || I(i, {
      class: `${i.class} ${this.config.classNames.control}`
    }) : i.class = this.config.classNames.control, e) {
      case "play":
        s.toggle = !0, s.label = "play", s.labelPressed = "pause", s.icon = "play", s.iconPressed = "pause";
        break;
      case "mute":
        s.toggle = !0, s.label = "mute", s.labelPressed = "unmute", s.icon = "volume", s.iconPressed = "muted";
        break;
      case "captions":
        s.toggle = !0, s.label = "enableCaptions", s.labelPressed = "disableCaptions", s.icon = "captions-off", s.iconPressed = "captions-on";
        break;
      case "fullscreen":
        s.toggle = !0, s.label = "enterFullscreen", s.labelPressed = "exitFullscreen", s.icon = "enter-fullscreen", s.iconPressed = "exit-fullscreen";
        break;
      case "play-large":
        i.class += ` ${this.config.classNames.control}--overlaid`, n = "play", s.label = "play", s.icon = "play";
        break;
      default:
        r.empty(s.label) && (s.label = n), r.empty(s.icon) && (s.icon = e);
    }
    const a = v(s.element);
    return s.toggle ? (a.appendChild(
      p.createIcon.call(this, s.iconPressed, {
        class: "icon--pressed"
      })
    ), a.appendChild(
      p.createIcon.call(this, s.icon, {
        class: "icon--not-pressed"
      })
    ), a.appendChild(
      p.createLabel.call(this, s.labelPressed, {
        class: "label--pressed"
      })
    ), a.appendChild(
      p.createLabel.call(this, s.label, {
        class: "label--not-pressed"
      })
    )) : (a.appendChild(p.createIcon.call(this, s.icon)), a.appendChild(p.createLabel.call(this, s.label))), I(i, R(this.config.selectors.buttons[n], i)), Ae(a, i), n === "play" ? (r.array(this.elements.buttons[n]) || (this.elements.buttons[n] = []), this.elements.buttons[n].push(a)) : this.elements.buttons[n] = a, a;
  },
  // Create an <input type='range'>
  createRange(e, t) {
    const i = v(
      "input",
      I(
        R(this.config.selectors.inputs[e]),
        {
          type: "range",
          min: 0,
          max: 100,
          step: 0.01,
          value: 0,
          autocomplete: "off",
          // A11y fixes for https://github.com/sampotts/plyr/issues/905
          role: "slider",
          "aria-label": H.get(e, this.config),
          "aria-valuemin": 0,
          "aria-valuemax": 100,
          "aria-valuenow": 0
        },
        t
      )
    );
    return this.elements.inputs[e] = i, p.updateRangeFill.call(this, i), jt.setup(i), i;
  },
  // Create a <progress>
  createProgress(e, t) {
    const i = v(
      "progress",
      I(
        R(this.config.selectors.display[e]),
        {
          min: 0,
          max: 100,
          value: 0,
          role: "progressbar",
          "aria-hidden": !0
        },
        t
      )
    );
    if (e !== "volume") {
      i.appendChild(v("span", null, "0"));
      const n = {
        played: "played",
        buffer: "buffered"
      }[e], s = n ? H.get(n, this.config) : "";
      i.textContent = `% ${s.toLowerCase()}`;
    }
    return this.elements.display[e] = i, i;
  },
  // Create time display
  createTime(e, t) {
    const i = R(this.config.selectors.display[e], t), n = v(
      "div",
      I(i, {
        class: `${i.class ? i.class : ""} ${this.config.classNames.display.time} `.trim(),
        "aria-label": H.get(e, this.config),
        role: "timer"
      }),
      "00:00"
    );
    return this.elements.display[e] = n, n;
  },
  // Bind keyboard shortcuts for a menu item
  // We have to bind to keyup otherwise Firefox triggers a click when a keydown event handler shifts focus
  // https://bugzilla.mozilla.org/show_bug.cgi?id=1220143
  bindMenuItemShortcuts(e, t) {
    E.call(
      this,
      e,
      "keydown keyup",
      (i) => {
        if (![" ", "ArrowUp", "ArrowDown", "ArrowRight"].includes(i.key) || (i.preventDefault(), i.stopPropagation(), i.type === "keydown"))
          return;
        const n = G(e, '[role="menuitemradio"]');
        if (!n && [" ", "ArrowRight"].includes(i.key))
          p.showMenuPanel.call(this, t, !0);
        else {
          let s;
          i.key !== " " && (i.key === "ArrowDown" || n && i.key === "ArrowRight" ? (s = e.nextElementSibling, r.element(s) || (s = e.parentNode.firstElementChild)) : (s = e.previousElementSibling, r.element(s) || (s = e.parentNode.lastElementChild)), ve.call(this, s, !0));
        }
      },
      !1
    ), E.call(this, e, "keyup", (i) => {
      i.key === "Return" && p.focusFirstMenuItem.call(this, null, !0);
    });
  },
  // Create a settings menu item
  createMenuItem({ value: e, list: t, type: i, title: n, badge: s = null, checked: a = !1 }) {
    const o = R(this.config.selectors.inputs[i]), l = v(
      "button",
      I(o, {
        type: "button",
        role: "menuitemradio",
        class: `${this.config.classNames.control} ${o.class ? o.class : ""}`.trim(),
        "aria-checked": a,
        value: e
      })
    ), c = v("span");
    c.innerHTML = n, r.element(s) && c.appendChild(s), l.appendChild(c), Object.defineProperty(l, "checked", {
      enumerable: !0,
      get() {
        return l.getAttribute("aria-checked") === "true";
      },
      set(u) {
        u && Array.from(l.parentNode.children).filter((m) => G(m, '[role="menuitemradio"]')).forEach((m) => m.setAttribute("aria-checked", "false")), l.setAttribute("aria-checked", u ? "true" : "false");
      }
    }), this.listeners.bind(
      l,
      "click keyup",
      (u) => {
        if (!(r.keyboardEvent(u) && u.key !== " ")) {
          switch (u.preventDefault(), u.stopPropagation(), l.checked = !0, i) {
            case "language":
              this.currentTrack = Number(e);
              break;
            case "quality":
              this.quality = e;
              break;
            case "speed":
              this.speed = Number.parseFloat(e);
              break;
          }
          p.showMenuPanel.call(this, "home", r.keyboardEvent(u));
        }
      },
      i,
      !1
    ), p.bindMenuItemShortcuts.call(this, l, i), t.appendChild(l);
  },
  // Format a time for display
  formatTime(e = 0, t = !1) {
    if (!r.number(e))
      return e;
    const i = ht(this.duration) > 0;
    return we(e, i, t);
  },
  // Update the displayed time
  updateTimeDisplay(e = null, t = 0, i = !1) {
    !r.element(e) || !r.number(t) || (e.textContent = p.formatTime(t, i));
  },
  // Update volume UI and storage
  updateVolume() {
    this.supported.ui && (r.element(this.elements.inputs.volume) && p.setRange.call(this, this.elements.inputs.volume, this.muted ? 0 : this.volume), r.element(this.elements.buttons.mute) && (this.elements.buttons.mute.pressed = this.muted || this.volume === 0));
  },
  // Update seek value and lower fill
  setRange(e, t = 0) {
    r.element(e) && (e.value = t, p.updateRangeFill.call(this, e));
  },
  // Update <progress> elements
  updateProgress(e) {
    if (!this.supported.ui || !r.event(e))
      return;
    let t = 0;
    const i = (n, s) => {
      const a = r.number(s) ? s : 0, o = r.element(n) ? n : this.elements.display.buffer;
      if (r.element(o)) {
        o.value = a;
        const l = o.getElementsByTagName("span")[0];
        r.element(l) && (l.childNodes[0].nodeValue = a);
      }
    };
    if (e)
      switch (e.type) {
        case "timeupdate":
        case "seeking":
        case "seeked":
          t = ci(this.currentTime, this.duration), e.type === "timeupdate" && p.setRange.call(this, this.elements.inputs.seek, t);
          break;
        case "playing":
        case "progress":
          i(this.elements.display.buffer, this.buffered * 100);
          break;
      }
  },
  // Webkit polyfill for lower fill range
  updateRangeFill(e) {
    const t = r.event(e) ? e.target : e;
    if (!(!r.element(t) || t.getAttribute("type") !== "range")) {
      if (G(t, this.config.selectors.inputs.seek)) {
        t.setAttribute("aria-valuenow", this.currentTime);
        const i = p.formatTime(this.currentTime), n = p.formatTime(this.duration), s = H.get("seekLabel", this.config);
        t.setAttribute(
          "aria-valuetext",
          s.replace("{currentTime}", i).replace("{duration}", n)
        );
      } else if (G(t, this.config.selectors.inputs.volume)) {
        const i = t.value * 100;
        t.setAttribute("aria-valuenow", i), t.setAttribute("aria-valuetext", `${i.toFixed(1)}%`);
      } else
        t.setAttribute("aria-valuenow", t.value);
      !j.isWebKit && !j.isIPadOS || t.style.setProperty("--value", `${t.value / t.max * 100}%`);
    }
  },
  // Update hover tooltip for seeking
  updateSeekTooltip(e) {
    var c, u;
    if (!this.config.tooltips.seek || !r.element(this.elements.inputs.seek) || !r.element(this.elements.display.seekTooltip) || this.duration === 0)
      return;
    const t = this.elements.display.seekTooltip, i = `${this.config.classNames.tooltip}--visible`, n = (m) => P(t, i, m);
    if (this.touch) {
      n(!1);
      return;
    }
    let s = 0;
    const a = this.elements.progress.getBoundingClientRect();
    if (r.event(e)) {
      const m = e.pageX - e.clientX;
      s = 100 / a.width * (e.pageX - a.left - m);
    } else if (pe(t, i))
      s = Number.parseFloat(t.style.left, 10);
    else
      return;
    s < 0 ? s = 0 : s > 100 && (s = 100);
    const o = this.duration / 100 * s;
    t.textContent = p.formatTime(o);
    const l = (u = (c = this.config.markers) == null ? void 0 : c.points) == null ? void 0 : u.find(({ time: m }) => m === Math.round(o));
    l && t.insertAdjacentHTML("afterbegin", `${l.label}<br>`), t.style.left = `${s}%`, r.event(e) && ["mouseenter", "mouseleave"].includes(e.type) && n(e.type === "mouseenter");
  },
  // Handle time change event
  timeUpdate(e) {
    const t = !r.element(this.elements.display.duration) && this.config.invertTime;
    p.updateTimeDisplay.call(
      this,
      this.elements.display.currentTime,
      t ? this.duration - this.currentTime : this.currentTime,
      t
    ), !(e && e.type === "timeupdate" && this.media.seeking) && p.updateProgress.call(this, e);
  },
  // Show the duration on metadataloaded or durationchange events
  durationUpdate() {
    if (!this.supported.ui || !this.config.invertTime && this.currentTime)
      return;
    if (this.duration >= 2 ** 32) {
      Q(this.elements.display.currentTime, !0), Q(this.elements.progress, !0);
      return;
    }
    r.element(this.elements.inputs.seek) && this.elements.inputs.seek.setAttribute("aria-valuemax", this.duration);
    const e = r.element(this.elements.display.duration);
    !e && this.config.displayDuration && this.paused && p.updateTimeDisplay.call(this, this.elements.display.currentTime, this.duration), e && p.updateTimeDisplay.call(this, this.elements.display.duration, this.duration), this.config.markers.enabled && p.setMarkers.call(this), p.updateSeekTooltip.call(this);
  },
  // Hide/show a tab
  toggleMenuButton(e, t) {
    Q(this.elements.settings.buttons[e], !t);
  },
  // Update the selected setting
  updateSetting(e, t, i) {
    const n = this.elements.settings.panels[e];
    let s = null, a = t;
    if (e === "captions")
      s = this.currentTrack;
    else {
      if (s = r.empty(i) ? this[e] : i, r.empty(s) && (s = this.config[e].default), !r.empty(this.options[e]) && !this.options[e].includes(s)) {
        this.debug.warn(`Unsupported value of '${s}' for ${e}`);
        return;
      }
      if (!this.config[e].options.includes(s)) {
        this.debug.warn(`Disabled value of '${s}' for ${e}`);
        return;
      }
    }
    if (r.element(a) || (a = n && n.querySelector('[role="menu"]')), !r.element(a))
      return;
    const o = this.elements.settings.buttons[e].querySelector(`.${this.config.classNames.menu.value}`);
    o.innerHTML = p.getLabel.call(this, e, s);
    const l = a && a.querySelector(`[value="${s}"]`);
    r.element(l) && (l.checked = !0);
  },
  // Translate a value into a nice label
  getLabel(e, t) {
    switch (e) {
      case "speed":
        return t === 1 ? H.get("normal", this.config) : `${t}&times;`;
      case "quality":
        if (r.number(t)) {
          const i = H.get(`qualityLabel.${t}`, this.config);
          return i.length ? i : `${t}p`;
        }
        return ut(t);
      case "captions":
        return S.getLabel.call(this);
      default:
        return null;
    }
  },
  // Set the quality menu
  setQualityMenu(e) {
    if (!r.element(this.elements.settings.panels.quality))
      return;
    const t = "quality", i = this.elements.settings.panels.quality.querySelector('[role="menu"]');
    r.array(e) && (this.options.quality = Se(e).filter((a) => this.config.quality.options.includes(a)));
    const n = !r.empty(this.options.quality) && this.options.quality.length > 1;
    if (p.toggleMenuButton.call(this, t, n), ue(i), p.checkMenu.call(this), !n)
      return;
    const s = (a) => {
      const o = H.get(`qualityBadge.${a}`, this.config);
      return o.length ? p.createBadge.call(this, o) : null;
    };
    this.options.quality.sort((a, o) => {
      const l = this.config.quality.options;
      return l.indexOf(a) > l.indexOf(o) ? 1 : -1;
    }).forEach((a) => {
      p.createMenuItem.call(this, {
        value: a,
        list: i,
        type: t,
        title: p.getLabel.call(this, "quality", a),
        badge: s(a)
      });
    }), p.updateSetting.call(this, t, i);
  },
  // Set the looping options
  /* setLoopMenu() {
          // Menu required
          if (!is.element(this.elements.settings.panels.loop)) {
              return;
          }
  
          const options = ['start', 'end', 'all', 'reset'];
          const list = this.elements.settings.panels.loop.querySelector('[role="menu"]');
  
          // Show the pane and tab
          toggleHidden(this.elements.settings.buttons.loop, false);
          toggleHidden(this.elements.settings.panels.loop, false);
  
          // Toggle the pane and tab
          const toggle = !is.empty(this.loop.options);
          controls.toggleMenuButton.call(this, 'loop', toggle);
  
          // Empty the menu
          emptyElement(list);
  
          options.forEach(option => {
              const item = createElement('li');
  
              const button = createElement(
                  'button',
                  extend(getAttributesFromSelector(this.config.selectors.buttons.loop), {
                      type: 'button',
                      class: this.config.classNames.control,
                      'data-plyr-loop-action': option,
                  }),
                  i18n.get(option, this.config)
              );
  
              if (['start', 'end'].includes(option)) {
                  const badge = controls.createBadge.call(this, '00:00');
                  button.appendChild(badge);
              }
  
              item.appendChild(button);
              list.appendChild(item);
          });
      }, */
  // Get current selected caption language
  // TODO: rework this to user the getter in the API?
  // Set a list of available captions languages
  setCaptionsMenu() {
    if (!r.element(this.elements.settings.panels.captions))
      return;
    const e = "captions", t = this.elements.settings.panels.captions.querySelector('[role="menu"]'), i = S.getTracks.call(this), n = !!i.length;
    if (p.toggleMenuButton.call(this, e, n), ue(t), p.checkMenu.call(this), !n)
      return;
    const s = i.map((a, o) => ({
      value: o,
      checked: this.captions.toggled && this.currentTrack === o,
      title: S.getLabel.call(this, a),
      badge: a.language && p.createBadge.call(this, a.language.toUpperCase()),
      list: t,
      type: "language"
    }));
    s.unshift({
      value: -1,
      checked: !this.captions.toggled,
      title: H.get("disabled", this.config),
      list: t,
      type: "language"
    }), s.forEach(p.createMenuItem.bind(this)), p.updateSetting.call(this, e, t);
  },
  // Set a list of available captions languages
  setSpeedMenu() {
    if (!r.element(this.elements.settings.panels.speed))
      return;
    const e = "speed", t = this.elements.settings.panels.speed.querySelector('[role="menu"]');
    this.options.speed = this.options.speed.filter((n) => n >= this.minimumSpeed && n <= this.maximumSpeed);
    const i = !r.empty(this.options.speed) && this.options.speed.length > 1;
    p.toggleMenuButton.call(this, e, i), ue(t), p.checkMenu.call(this), i && (this.options.speed.forEach((n) => {
      p.createMenuItem.call(this, {
        value: n,
        list: t,
        type: e,
        title: p.getLabel.call(this, "speed", n)
      });
    }), p.updateSetting.call(this, e, t));
  },
  // Check if we need to hide/show the settings menu
  checkMenu() {
    const { buttons: e } = this.elements.settings, t = !r.empty(e) && Object.values(e).some((i) => !i.hidden);
    Q(this.elements.settings.menu, !t);
  },
  // Focus the first menu item in a given (or visible) menu
  focusFirstMenuItem(e, t = !1) {
    if (this.elements.settings.popup.hidden)
      return;
    let i = e;
    r.element(i) || (i = Object.values(this.elements.settings.panels).find((s) => !s.hidden));
    const n = i.querySelector('[role^="menuitem"]');
    ve.call(this, n, t);
  },
  // Show/hide menu
  toggleMenu(e) {
    const { popup: t } = this.elements.settings, i = this.elements.buttons.settings;
    if (!r.element(t) || !r.element(i))
      return;
    const { hidden: n } = t;
    let s = n;
    if (r.boolean(e))
      s = e;
    else if (r.keyboardEvent(e) && e.key === "Escape")
      s = !1;
    else if (r.event(e)) {
      const a = r.function(e.composedPath) ? e.composedPath()[0] : e.target, o = t.contains(a);
      if (o || !o && e.target !== i && s)
        return;
    }
    i.setAttribute("aria-expanded", s), Q(t, !s), P(this.elements.container, this.config.classNames.menu.open, s), s && r.keyboardEvent(e) ? p.focusFirstMenuItem.call(this, null, !0) : !s && !n && ve.call(this, i, r.keyboardEvent(e));
  },
  // Get the natural size of a menu panel
  getMenuSize(e) {
    const t = e.cloneNode(!0);
    t.style.position = "absolute", t.style.opacity = 0, t.removeAttribute("hidden"), e.parentNode.appendChild(t);
    const i = t.scrollWidth, n = t.scrollHeight;
    return B(t), {
      width: i,
      height: n
    };
  },
  // Show a panel in the menu
  showMenuPanel(e = "", t = !1) {
    const i = this.elements.container.querySelector(`#plyr-settings-${this.id}-${e}`);
    if (!r.element(i))
      return;
    const n = i.parentNode, s = Array.from(n.children).find((a) => !a.hidden);
    if (O.transitions && !O.reducedMotion) {
      n.style.width = `${s.scrollWidth}px`, n.style.height = `${s.scrollHeight}px`;
      const a = p.getMenuSize.call(this, i), o = (l) => {
        l.target !== n || !["width", "height"].includes(l.propertyName) || (n.style.width = "", n.style.height = "", be.call(this, n, Ee, o));
      };
      E.call(this, n, Ee, o), n.style.width = `${a.width}px`, n.style.height = `${a.height}px`;
    }
    Q(s, !0), Q(i, !1), p.focusFirstMenuItem.call(this, i, t);
  },
  // Set the download URL
  setDownloadUrl() {
    const e = this.elements.buttons.download;
    r.element(e) && e.setAttribute("href", this.download);
  },
  // Build the default HTML
  create(e) {
    const {
      bindMenuItemShortcuts: t,
      createButton: i,
      createProgress: n,
      createRange: s,
      createTime: a,
      setQualityMenu: o,
      setSpeedMenu: l,
      showMenuPanel: c
    } = p;
    this.elements.controls = null, r.array(this.config.controls) && this.config.controls.includes("play-large") && this.elements.container.appendChild(i.call(this, "play-large"));
    const u = v("div", R(this.config.selectors.controls.wrapper));
    this.elements.controls = u;
    const m = { class: "plyr__controls__item" };
    return Se(r.array(this.config.controls) ? this.config.controls : []).forEach((b) => {
      if (b === "restart" && u.appendChild(i.call(this, "restart", m)), b === "rewind" && u.appendChild(i.call(this, "rewind", m)), b === "play" && u.appendChild(i.call(this, "play", m)), b === "fast-forward" && u.appendChild(i.call(this, "fast-forward", m)), b === "progress") {
        const d = v("div", {
          class: `${m.class} plyr__progress__container`
        }), h = v("div", R(this.config.selectors.progress));
        if (h.appendChild(
          s.call(this, "seek", {
            id: `plyr-seek-${e.id}`
          })
        ), h.appendChild(n.call(this, "buffer")), this.config.tooltips.seek) {
          const y = v(
            "span",
            {
              class: this.config.classNames.tooltip
            },
            "00:00"
          );
          h.appendChild(y), this.elements.display.seekTooltip = y;
        }
        this.elements.progress = h, d.appendChild(this.elements.progress), u.appendChild(d);
      }
      if (b === "current-time" && u.appendChild(a.call(this, "currentTime", m)), b === "duration" && u.appendChild(a.call(this, "duration", m)), b === "mute" || b === "volume") {
        let { volume: d } = this.elements;
        if ((!r.element(d) || !u.contains(d)) && (d = v(
          "div",
          I({}, m, {
            class: `${m.class} plyr__volume`.trim()
          })
        ), this.elements.volume = d, u.appendChild(d)), b === "mute" && d.appendChild(i.call(this, "mute")), b === "volume" && !j.isIos && !j.isIPadOS) {
          const h = {
            max: 1,
            step: 0.05,
            value: this.config.volume
          };
          d.appendChild(
            s.call(
              this,
              "volume",
              I(h, {
                id: `plyr-volume-${e.id}`
              })
            )
          );
        }
      }
      if (b === "captions" && u.appendChild(i.call(this, "captions", m)), b === "settings" && !r.empty(this.config.settings)) {
        const d = v(
          "div",
          I({}, m, {
            class: `${m.class} plyr__menu`.trim(),
            hidden: ""
          })
        );
        d.appendChild(
          i.call(this, "settings", {
            "aria-haspopup": !0,
            "aria-controls": `plyr-settings-${e.id}`,
            "aria-expanded": !1
          })
        );
        const h = v("div", {
          class: "plyr__menu__container",
          id: `plyr-settings-${e.id}`,
          hidden: ""
        }), y = v("div"), w = v("div", {
          id: `plyr-settings-${e.id}-home`
        }), T = v("div", {
          role: "menu"
        });
        w.appendChild(T), y.appendChild(w), this.elements.settings.panels.home = w, this.config.settings.forEach((A) => {
          const g = v(
            "button",
            I(R(this.config.selectors.buttons.settings), {
              type: "button",
              class: `${this.config.classNames.control} ${this.config.classNames.control}--forward`,
              role: "menuitem",
              "aria-haspopup": !0,
              hidden: ""
            })
          );
          t.call(this, g, A), E.call(this, g, "click", () => {
            c.call(this, A, !1);
          });
          const C = v("span", null, H.get(A, this.config)), $ = v("span", {
            class: this.config.classNames.menu.value
          });
          $.innerHTML = e[A], C.appendChild($), g.appendChild(C), T.appendChild(g);
          const D = v("div", {
            id: `plyr-settings-${e.id}-${A}`,
            hidden: ""
          }), N = v("button", {
            type: "button",
            class: `${this.config.classNames.control} ${this.config.classNames.control}--back`
          });
          N.appendChild(
            v(
              "span",
              {
                "aria-hidden": !0
              },
              H.get(A, this.config)
            )
          ), N.appendChild(
            v(
              "span",
              {
                class: this.config.classNames.hidden
              },
              H.get("menuBack", this.config)
            )
          ), E.call(
            this,
            D,
            "keydown",
            (M) => {
              M.key === "ArrowLeft" && (M.preventDefault(), M.stopPropagation(), c.call(this, "home", !0));
            },
            !1
          ), E.call(this, N, "click", () => {
            c.call(this, "home", !1);
          }), D.appendChild(N), D.appendChild(
            v("div", {
              role: "menu"
            })
          ), y.appendChild(D), this.elements.settings.buttons[A] = g, this.elements.settings.panels[A] = D;
        }), h.appendChild(y), d.appendChild(h), u.appendChild(d), this.elements.settings.popup = h, this.elements.settings.menu = d;
      }
      if (b === "pip" && O.pip && u.appendChild(i.call(this, "pip", m)), b === "airplay" && O.airplay && u.appendChild(i.call(this, "airplay", m)), b === "download") {
        const d = I({}, m, {
          element: "a",
          href: this.download,
          target: "_blank"
        });
        this.isHTML5 && (d.download = "");
        const { download: h } = this.config.urls;
        !r.url(h) && this.isEmbed && I(d, {
          icon: `logo-${this.provider}`,
          label: this.provider
        }), u.appendChild(i.call(this, "download", d));
      }
      b === "fullscreen" && u.appendChild(i.call(this, "fullscreen", m));
    }), this.isHTML5 && o.call(this, X.getQualityOptions.call(this)), l.call(this), u;
  },
  // Insert controls
  inject() {
    if (this.config.loadSprite) {
      const o = p.getIconUrl.call(this);
      o.cors && dt(o.url, "sprite-plyr");
    }
    this.id = Math.floor(Math.random() * 1e4);
    let e = null;
    this.elements.controls = null;
    const t = {
      id: this.id,
      seektime: this.config.seekTime,
      title: this.config.title
    };
    let i = !0;
    r.function(this.config.controls) && (this.config.controls = this.config.controls.call(this, t)), this.config.controls || (this.config.controls = []), r.element(this.config.controls) || r.string(this.config.controls) ? e = this.config.controls : (e = p.create.call(this, {
      id: this.id,
      seektime: this.config.seekTime,
      speed: this.speed,
      quality: this.quality,
      captions: S.getLabel.call(this)
      // TODO: Looping
      // loop: 'None',
    }), i = !1);
    const n = (o) => {
      let l = o;
      return Object.entries(t).forEach(([c, u]) => {
        l = te(l, `{${c}}`, u);
      }), l;
    };
    i && r.string(this.config.controls) && (e = n(e));
    let s;
    r.string(this.config.selectors.controls.container) && (s = document.querySelector(this.config.selectors.controls.container)), r.element(s) || (s = this.elements.container);
    const a = r.element(e) ? "insertAdjacentElement" : "insertAdjacentHTML";
    if (s[a]("afterbegin", e), r.element(this.elements.controls) || p.findElements.call(this), !r.empty(this.elements.buttons)) {
      const o = (l) => {
        const c = this.config.classNames.controlPressed;
        l.setAttribute("aria-pressed", "false"), Object.defineProperty(l, "pressed", {
          configurable: !0,
          enumerable: !0,
          get() {
            return pe(l, c);
          },
          set(u = !1) {
            P(l, c, u), l.setAttribute("aria-pressed", u ? "true" : "false");
          }
        });
      };
      Object.values(this.elements.buttons).filter(Boolean).forEach((l) => {
        r.array(l) || r.nodeList(l) ? Array.from(l).filter(Boolean).forEach(o) : o(l);
      });
    }
    if (j.isEdge && st(s), this.config.tooltips.controls) {
      const { classNames: o, selectors: l } = this.config, c = `${l.controls.wrapper} ${l.labels} .${o.hidden}`, u = ie.call(this, c);
      Array.from(u).forEach((m) => {
        P(m, this.config.classNames.hidden, !1), P(m, this.config.classNames.tooltip, !0);
      });
    }
  },
  // Set media metadata
  setMediaMetadata() {
    try {
      "mediaSession" in navigator && (navigator.mediaSession.metadata = new window.MediaMetadata({
        title: this.config.mediaMetadata.title,
        artist: this.config.mediaMetadata.artist,
        album: this.config.mediaMetadata.album,
        artwork: this.config.mediaMetadata.artwork
      }));
    } catch {
    }
  },
  // Add markers
  setMarkers() {
    var o, l;
    if (!this.duration || this.elements.markers) return;
    const e = (l = (o = this.config.markers) == null ? void 0 : o.points) == null ? void 0 : l.filter(({ time: c }) => c > 0 && c < this.duration);
    if (!(e != null && e.length)) return;
    const t = document.createDocumentFragment(), i = document.createDocumentFragment();
    let n = null;
    const s = `${this.config.classNames.tooltip}--visible`, a = (c) => P(n, s, c);
    e.forEach((c) => {
      const u = v(
        "span",
        {
          class: this.config.classNames.marker
        },
        ""
      ), m = `${c.time / this.duration * 100}%`;
      n && (u.addEventListener("mouseenter", () => {
        c.label || (n.style.left = m, n.innerHTML = c.label, a(!0));
      }), u.addEventListener("mouseleave", () => {
        a(!1);
      })), u.addEventListener("click", () => {
        this.currentTime = c.time;
      }), u.style.left = m, i.appendChild(u);
    }), t.appendChild(i), this.config.tooltips.seek || (n = v(
      "span",
      {
        class: this.config.classNames.tooltip
      },
      ""
    ), t.appendChild(n)), this.elements.markers = {
      points: i,
      tip: n
    }, this.elements.progress.appendChild(t);
  }
};
function mt(e, t = !0) {
  let i = e;
  if (t) {
    const n = document.createElement("a");
    n.href = i, i = n.href;
  }
  try {
    return new URL(i);
  } catch {
    return null;
  }
}
function pt(e) {
  const t = new URLSearchParams();
  return r.object(e) && Object.entries(e).forEach(([i, n]) => {
    t.set(i, n);
  }), t;
}
const S = {
  // Setup captions
  setup() {
    if (!this.supported.ui)
      return;
    if (!this.isVideo || this.isYouTube || this.isHTML5 && !O.textTracks) {
      r.array(this.config.controls) && this.config.controls.includes("settings") && this.config.settings.includes("captions") && p.setCaptionsMenu.call(this);
      return;
    }
    if (r.element(this.elements.captions) || (this.elements.captions = v("div", R(this.config.selectors.captions)), this.elements.captions.setAttribute("dir", "auto"), Gt(this.elements.captions, this.elements.wrapper)), j.isIE && window.URL) {
      const s = this.media.querySelectorAll("track");
      Array.from(s).forEach((a) => {
        const o = a.getAttribute("src"), l = mt(o);
        l !== null && l.hostname !== window.location.href.hostname && ["http:", "https:"].includes(l.protocol) && le(o, "blob").then((c) => {
          a.setAttribute("src", window.URL.createObjectURL(c));
        }).catch(() => {
          B(a);
        });
      });
    }
    const e = navigator.languages || [navigator.language || navigator.userLanguage || "en"], t = Se(e.map((s) => s.split("-")[0]));
    let i = (this.storage.get("language") || this.captions.language || this.config.captions.language || "auto").toLowerCase();
    i === "auto" && ([i] = t);
    let n = this.storage.get("captions") || this.captions.active;
    if (r.boolean(n) || ({ active: n } = this.config.captions), Object.assign(this.captions, {
      toggled: !1,
      active: n,
      language: i,
      languages: t
    }), this.isHTML5) {
      const s = this.config.captions.update ? "addtrack removetrack" : "removetrack";
      E.call(this, this.media.textTracks, s, S.update.bind(this));
    }
    setTimeout(S.update.bind(this), 0);
  },
  // Update available language options in settings based on tracks
  update() {
    const e = S.getTracks.call(this, !0), { active: t, language: i, meta: n, currentTrackNode: s } = this.captions, a = !!e.find((o) => o.language === i);
    this.isHTML5 && this.isVideo && e.filter((o) => !n.get(o)).forEach((o) => {
      this.debug.log("Track added", o), n.set(o, {
        default: o.mode === "showing"
      }), o.mode === "showing" && (o.mode = "hidden"), E.call(this, o, "cuechange", () => S.updateCues.call(this));
    }), (a && this.language !== i || !e.includes(s)) && (S.setLanguage.call(this, i), S.toggle.call(this, t && a)), this.elements && P(this.elements.container, this.config.classNames.captions.enabled, !r.empty(e)), r.array(this.config.controls) && this.config.controls.includes("settings") && this.config.settings.includes("captions") && p.setCaptionsMenu.call(this);
  },
  // Toggle captions display
  // Used internally for the toggleCaptions method, with the passive option forced to false
  toggle(e, t = !0) {
    if (!this.supported.ui)
      return;
    const { toggled: i } = this.captions, n = this.config.classNames.captions.active, s = r.nullOrUndefined(e) ? !i : e;
    if (s !== i) {
      if (t || (this.captions.active = s, this.storage.set({ captions: s })), !this.language && s && !t) {
        const a = S.getTracks.call(this), o = S.findTrack.call(this, [this.captions.language, ...this.captions.languages], !0);
        this.captions.language = o.language, S.set.call(this, a.indexOf(o));
        return;
      }
      this.elements.buttons.captions && (this.elements.buttons.captions.pressed = s), P(this.elements.container, n, s), this.captions.toggled = s, p.updateSetting.call(this, "captions"), k.call(this, this.media, s ? "captionsenabled" : "captionsdisabled");
    }
    setTimeout(() => {
      s && this.captions.toggled && (this.captions.currentTrackNode.mode = "hidden");
    });
  },
  // Set captions by track index
  // Used internally for the currentTrack setter with the passive option forced to false
  set(e, t = !0) {
    const i = S.getTracks.call(this);
    if (e === -1) {
      S.toggle.call(this, !1, t);
      return;
    }
    if (!r.number(e)) {
      this.debug.warn("Invalid caption argument", e);
      return;
    }
    if (!(e in i)) {
      this.debug.warn("Track not found", e);
      return;
    }
    if (this.captions.currentTrack !== e) {
      this.captions.currentTrack = e;
      const n = i[e], { language: s } = n || {};
      this.captions.currentTrackNode = n, p.updateSetting.call(this, "captions"), t || (this.captions.language = s, this.storage.set({ language: s })), this.isVimeo && this.embed.enableTextTrack(s), k.call(this, this.media, "languagechange");
    }
    S.toggle.call(this, !0, t), this.isHTML5 && this.isVideo && S.updateCues.call(this);
  },
  // Set captions by language
  // Used internally for the language setter with the passive option forced to false
  setLanguage(e, t = !0) {
    if (!r.string(e)) {
      this.debug.warn("Invalid language argument", e);
      return;
    }
    const i = e.toLowerCase();
    this.captions.language = i;
    const n = S.getTracks.call(this), s = S.findTrack.call(this, [i]);
    S.set.call(this, n.indexOf(s), t);
  },
  // Get current valid caption tracks
  // If update is false it will also ignore tracks without metadata
  // This is used to "freeze" the language options when captions.update is false
  getTracks(e = !1) {
    return Array.from((this.media || {}).textTracks || []).filter((i) => !this.isHTML5 || e || this.captions.meta.has(i)).filter((i) => ["captions", "subtitles"].includes(i.kind));
  },
  // Match tracks based on languages and get the first
  findTrack(e, t = !1) {
    const i = S.getTracks.call(this), n = (o) => Number((this.captions.meta.get(o) || {}).default), s = Array.from(i).sort((o, l) => n(l) - n(o));
    let a;
    return e.every((o) => (a = s.find((l) => l.language === o), !a)), a || (t ? s[0] : void 0);
  },
  // Get the current track
  getCurrentTrack() {
    return S.getTracks.call(this)[this.currentTrack];
  },
  // Get UI label for track
  getLabel(e) {
    let t = e;
    return !r.track(t) && O.textTracks && this.captions.toggled && (t = S.getCurrentTrack.call(this)), r.track(t) ? r.empty(t.label) ? r.empty(t.language) ? H.get("enabled", this.config) : e.language.toUpperCase() : t.label : H.get("disabled", this.config);
  },
  // Update captions using current track's active cues
  // Also optional array argument in case there isn't any track (ex: vimeo)
  updateCues(e) {
    if (!this.supported.ui)
      return;
    if (!r.element(this.elements.captions)) {
      this.debug.warn("No captions element to render to");
      return;
    }
    if (!r.nullOrUndefined(e) && !Array.isArray(e)) {
      this.debug.warn("updateCues: Invalid input", e);
      return;
    }
    let t = e;
    if (!t) {
      const s = S.getCurrentTrack.call(this);
      t = Array.from((s || {}).activeCues || []).map((a) => a.getCueAsHTML()).map(mi);
    }
    const i = t.map((s) => s.trim()).join(`
`);
    if (i !== this.elements.captions.innerHTML) {
      ue(this.elements.captions);
      const s = v("span", R(this.config.selectors.caption));
      s.innerHTML = i, this.elements.captions.appendChild(s), k.call(this, this.media, "cuechange");
    }
  }
}, ft = {
  // Disable
  enabled: !0,
  // Custom media title
  title: "",
  // Logging to console
  debug: !1,
  // Auto play (if supported)
  autoplay: !1,
  // Only allow one media playing at once (vimeo only)
  autopause: !0,
  // Allow inline playback on iOS
  playsinline: !0,
  // Default time to skip when rewind/fast forward
  seekTime: 10,
  // Default volume
  volume: 1,
  muted: !1,
  // Pass a custom duration
  duration: null,
  // Display the media duration on load in the current time position
  // If you have opted to display both duration and currentTime, this is ignored
  displayDuration: !0,
  // Invert the current time to be a countdown
  invertTime: !0,
  // Clicking the currentTime inverts it's value to show time left rather than elapsed
  toggleInvert: !0,
  // Force an aspect ratio
  // The format must be `'w:h'` (e.g. `'16:9'`)
  ratio: null,
  // Click video container to play/pause
  clickToPlay: !0,
  // Auto hide the controls
  hideControls: !0,
  // Reset to start when playback ended
  resetOnEnd: !1,
  // Disable the standard context menu
  disableContextMenu: !0,
  // Sprite (for icons)
  loadSprite: !0,
  iconPrefix: "plyr",
  iconUrl: "https://cdn.plyr.io/3.8.3/plyr.svg",
  // Blank video (used to prevent errors on source change)
  blankVideo: "https://cdn.plyr.io/static/blank.mp4",
  // Quality default
  quality: {
    default: 576,
    // The options to display in the UI, if available for the source media
    options: [4320, 2880, 2160, 1440, 1080, 720, 576, 480, 360, 240],
    forced: !1,
    onChange: null
  },
  // Set loops
  loop: {
    active: !1
    // start: null,
    // end: null,
  },
  // Speed default and options to display
  speed: {
    selected: 1,
    // The options to display in the UI, if available for the source media (e.g. Vimeo and YouTube only support 0.5x-4x)
    options: [0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 4]
  },
  // Keyboard shortcut settings
  keyboard: {
    focused: !0,
    global: !1
  },
  // Display tooltips
  tooltips: {
    controls: !1,
    seek: !0
  },
  // Captions settings
  captions: {
    active: !1,
    language: "auto",
    // Listen to new tracks added after Plyr is initialized.
    // This is needed for streaming captions, but may result in unselectable options
    update: !1
  },
  // Fullscreen settings
  fullscreen: {
    enabled: !0,
    // Allow fullscreen?
    fallback: !0,
    // Fallback using full viewport/window
    iosNative: !1
    // Use the native fullscreen in iOS (disables custom controls)
    // Selector for the fullscreen container so contextual / non-player content can remain visible in fullscreen mode
    // Non-ancestors of the player element will be ignored
    // container: null, // defaults to the player element
  },
  // Local storage
  storage: {
    enabled: !0,
    key: "plyr"
  },
  // Default controls
  controls: [
    "play-large",
    // 'restart',
    // 'rewind',
    "play",
    // 'fast-forward',
    "progress",
    "current-time",
    // 'duration',
    "mute",
    "volume",
    "captions",
    "settings",
    "pip",
    "airplay",
    // 'download',
    "fullscreen"
  ],
  settings: ["captions", "quality", "speed"],
  // Localisation
  i18n: {
    restart: "Restart",
    rewind: "Rewind {seektime}s",
    play: "Play",
    pause: "Pause",
    fastForward: "Forward {seektime}s",
    seek: "Seek",
    seekLabel: "{currentTime} of {duration}",
    played: "Played",
    buffered: "Buffered",
    currentTime: "Current time",
    duration: "Duration",
    volume: "Volume",
    mute: "Mute",
    unmute: "Unmute",
    enableCaptions: "Enable captions",
    disableCaptions: "Disable captions",
    download: "Download",
    enterFullscreen: "Enter fullscreen",
    exitFullscreen: "Exit fullscreen",
    frameTitle: "Player for {title}",
    captions: "Captions",
    settings: "Settings",
    pip: "PIP",
    menuBack: "Go back to previous menu",
    speed: "Speed",
    normal: "Normal",
    quality: "Quality",
    loop: "Loop",
    start: "Start",
    end: "End",
    all: "All",
    reset: "Reset",
    disabled: "Disabled",
    enabled: "Enabled",
    advertisement: "Ad",
    qualityBadge: {
      2160: "4K",
      1440: "HD",
      1080: "HD",
      720: "HD",
      576: "SD",
      480: "SD"
    }
  },
  // URLs
  urls: {
    download: null,
    vimeo: {
      sdk: "https://player.vimeo.com/api/player.js",
      iframe: "https://player.vimeo.com/video/{0}?{1}",
      api: "https://vimeo.com/api/oembed.json?url={0}"
    },
    youtube: {
      sdk: "https://www.youtube.com/iframe_api",
      api: "https://noembed.com/embed?url=https://www.youtube.com/watch?v={0}"
    },
    googleIMA: {
      sdk: "https://imasdk.googleapis.com/js/sdkloader/ima3.js"
    }
  },
  // Custom control listeners
  listeners: {
    seek: null,
    play: null,
    pause: null,
    restart: null,
    rewind: null,
    fastForward: null,
    mute: null,
    volume: null,
    captions: null,
    download: null,
    fullscreen: null,
    pip: null,
    airplay: null,
    speed: null,
    quality: null,
    loop: null,
    language: null
  },
  // Events to watch and bubble
  events: [
    // Events to watch on HTML5 media elements and bubble
    // https://developer.mozilla.org/en/docs/Web/Guide/Events/Media_events
    "ended",
    "progress",
    "stalled",
    "playing",
    "waiting",
    "canplay",
    "canplaythrough",
    "loadstart",
    "loadeddata",
    "loadedmetadata",
    "timeupdate",
    "volumechange",
    "play",
    "pause",
    "error",
    "seeking",
    "seeked",
    "emptied",
    "ratechange",
    "cuechange",
    // Custom events
    "download",
    "enterfullscreen",
    "exitfullscreen",
    "captionsenabled",
    "captionsdisabled",
    "languagechange",
    "controlshidden",
    "controlsshown",
    "ready",
    // YouTube
    "statechange",
    // Quality
    "qualitychange",
    // Ads
    "adsloaded",
    "adscontentpause",
    "adscontentresume",
    "adstarted",
    "adsmidpoint",
    "adscomplete",
    "adsallcomplete",
    "adsimpression",
    "adsclick"
  ],
  // Selectors
  // Change these to match your template if using custom HTML
  selectors: {
    editable: "input, textarea, select, [contenteditable]",
    container: ".plyr",
    controls: {
      container: null,
      wrapper: ".plyr__controls"
    },
    labels: "[data-plyr]",
    buttons: {
      play: '[data-plyr="play"]',
      pause: '[data-plyr="pause"]',
      restart: '[data-plyr="restart"]',
      rewind: '[data-plyr="rewind"]',
      fastForward: '[data-plyr="fast-forward"]',
      mute: '[data-plyr="mute"]',
      captions: '[data-plyr="captions"]',
      download: '[data-plyr="download"]',
      fullscreen: '[data-plyr="fullscreen"]',
      pip: '[data-plyr="pip"]',
      airplay: '[data-plyr="airplay"]',
      settings: '[data-plyr="settings"]',
      loop: '[data-plyr="loop"]'
    },
    inputs: {
      seek: '[data-plyr="seek"]',
      volume: '[data-plyr="volume"]',
      speed: '[data-plyr="speed"]',
      language: '[data-plyr="language"]',
      quality: '[data-plyr="quality"]'
    },
    display: {
      currentTime: ".plyr__time--current",
      duration: ".plyr__time--duration",
      buffer: ".plyr__progress__buffer",
      loop: ".plyr__progress__loop",
      // Used later
      volume: ".plyr__volume--display"
    },
    progress: ".plyr__progress",
    captions: ".plyr__captions",
    caption: ".plyr__caption"
  },
  // Class hooks added to the player in different states
  classNames: {
    type: "plyr--{0}",
    provider: "plyr--{0}",
    video: "plyr__video-wrapper",
    embed: "plyr__video-embed",
    videoFixedRatio: "plyr__video-wrapper--fixed-ratio",
    embedContainer: "plyr__video-embed__container",
    poster: "plyr__poster",
    posterEnabled: "plyr__poster-enabled",
    ads: "plyr__ads",
    control: "plyr__control",
    controlPressed: "plyr__control--pressed",
    playing: "plyr--playing",
    paused: "plyr--paused",
    stopped: "plyr--stopped",
    loading: "plyr--loading",
    hover: "plyr--hover",
    tooltip: "plyr__tooltip",
    cues: "plyr__cues",
    marker: "plyr__progress__marker",
    hidden: "plyr__sr-only",
    hideControls: "plyr--hide-controls",
    isTouch: "plyr--is-touch",
    uiSupported: "plyr--full-ui",
    noTransition: "plyr--no-transition",
    display: {
      time: "plyr__time"
    },
    menu: {
      value: "plyr__menu__value",
      badge: "plyr__badge",
      open: "plyr--menu-open"
    },
    captions: {
      enabled: "plyr--captions-enabled",
      active: "plyr--captions-active"
    },
    fullscreen: {
      enabled: "plyr--fullscreen-enabled",
      fallback: "plyr--fullscreen-fallback"
    },
    pip: {
      supported: "plyr--pip-supported",
      active: "plyr--pip-active"
    },
    airplay: {
      supported: "plyr--airplay-supported",
      active: "plyr--airplay-active"
    },
    previewThumbnails: {
      // Tooltip thumbs
      thumbContainer: "plyr__preview-thumb",
      thumbContainerShown: "plyr__preview-thumb--is-shown",
      imageContainer: "plyr__preview-thumb__image-container",
      timeContainer: "plyr__preview-thumb__time-container",
      // Scrubbing
      scrubbingContainer: "plyr__preview-scrubbing",
      scrubbingContainerShown: "plyr__preview-scrubbing--is-shown"
    }
  },
  // Embed attributes
  attributes: {
    embed: {
      provider: "data-plyr-provider",
      id: "data-plyr-embed-id",
      hash: "data-plyr-embed-hash"
    }
  },
  // Advertisements plugin
  // Register for an account here: http://vi.ai/publisher-video-monetization/?aid=plyrio
  ads: {
    enabled: !1,
    publisherId: "",
    tagUrl: ""
  },
  // Preview Thumbnails plugin
  previewThumbnails: {
    enabled: !1,
    src: "",
    withCredentials: !1
  },
  // Vimeo plugin
  vimeo: {
    byline: !1,
    portrait: !1,
    title: !1,
    speed: !0,
    transparent: !1,
    // Custom settings from Plyr
    customControls: !0,
    referrerPolicy: null,
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLIFrameElement/referrerPolicy
    // Whether the owner of the video has a Pro or Business account
    // (which allows us to properly hide controls without CSS hacks, etc)
    premium: !1
  },
  // YouTube plugin
  youtube: {
    rel: 0,
    // No related vids
    showinfo: 0,
    // Hide info
    iv_load_policy: 3,
    // Hide annotations
    modestbranding: 1,
    // Hide logos as much as possible (they still show one in the corner when paused)
    // Custom settings from Plyr
    customControls: !0,
    noCookie: !1
    // Whether to use an alternative version of YouTube without cookies
  },
  // Media Metadata
  mediaMetadata: {
    title: "",
    artist: "",
    album: "",
    artwork: []
  },
  // Markers
  markers: {
    enabled: !1,
    points: []
  }
}, ke = {
  active: "picture-in-picture",
  inactive: "inline"
}, Y = {
  html5: "html5",
  youtube: "youtube",
  vimeo: "vimeo"
}, Te = {
  audio: "audio",
  video: "video"
};
function gi(e) {
  return /^(?:https?:\/\/)?(?:www\.)?(?:youtube\.com|youtube-nocookie\.com|youtu\.?be)\/.+$/.test(e) ? Y.youtube : /^https?:\/\/player.vimeo.com\/video\/\d{0,9}(?=\b|\/)/.test(e) ? Y.vimeo : null;
}
function Ce() {
}
class yi {
  constructor(t = !1) {
    this.enabled = window.console && t, this.enabled && this.log("Debugging enabled");
  }
  get log() {
    return this.enabled ? Function.prototype.bind.call(console.log, console) : Ce;
  }
  get warn() {
    return this.enabled ? Function.prototype.bind.call(console.warn, console) : Ce;
  }
  get error() {
    return this.enabled ? Function.prototype.bind.call(console.error, console) : Ce;
  }
}
class U {
  constructor(t) {
    f(this, "onChange", () => {
      if (!this.supported) return;
      const t = this.player.elements.buttons.fullscreen;
      r.element(t) && (t.pressed = this.active);
      const i = this.target === this.player.media ? this.target : this.player.elements.container;
      k.call(this.player, i, this.active ? "enterfullscreen" : "exitfullscreen", !0);
    });
    f(this, "toggleFallback", (t = !1) => {
      if (t ? this.scrollPosition = {
        x: window.scrollX ?? 0,
        y: window.scrollY ?? 0
      } : window.scrollTo(this.scrollPosition.x, this.scrollPosition.y), document.body.style.overflow = t ? "hidden" : "", P(this.target, this.player.config.classNames.fullscreen.fallback, t), j.isIos) {
        let i = document.head.querySelector('meta[name="viewport"]');
        const n = "viewport-fit=cover";
        i || (i = document.createElement("meta"), i.setAttribute("name", "viewport"));
        const s = r.string(i.content) && i.content.includes(n);
        t ? (this.cleanupViewport = !s, s || (i.content += `,${n}`)) : this.cleanupViewport && (i.content = i.content.split(",").filter((a) => a.trim() !== n).join(","));
      }
      this.onChange();
    });
    // Trap focus inside container
    f(this, "trapFocus", (t) => {
      if (j.isIos || j.isIPadOS || !this.active || t.key !== "Tab") return;
      const i = document.activeElement, n = ie.call(this.player, "a[href], button:not(:disabled), input:not(:disabled), [tabindex]"), [s] = n, a = n[n.length - 1];
      i === a && !t.shiftKey ? (s.focus(), t.preventDefault()) : i === s && t.shiftKey && (a.focus(), t.preventDefault());
    });
    // Update UI
    f(this, "update", () => {
      if (this.supported) {
        let t;
        this.forceFallback ? t = "Fallback (forced)" : U.nativeSupported ? t = "Native" : t = "Fallback", this.player.debug.log(`${t} fullscreen enabled`);
      } else
        this.player.debug.log("Fullscreen not supported and fallback disabled");
      P(this.player.elements.container, this.player.config.classNames.fullscreen.enabled, this.supported);
    });
    // Make an element fullscreen
    f(this, "enter", () => {
      this.supported && (j.isIos && this.player.config.fullscreen.iosNative ? this.player.isVimeo ? this.player.embed.requestFullscreen() : this.target.webkitEnterFullscreen() : !U.nativeSupported || this.forceFallback ? this.toggleFallback(!0) : this.prefix ? r.empty(this.prefix) || this.target[`${this.prefix}Request${this.property}`]() : this.target.requestFullscreen({ navigationUI: "hide" }));
    });
    // Bail from fullscreen
    f(this, "exit", () => {
      if (this.supported) {
        if (j.isIos && this.player.config.fullscreen.iosNative)
          this.player.isVimeo ? this.player.embed.exitFullscreen() : this.target.webkitEnterFullscreen(), W(this.player.play());
        else if (!U.nativeSupported || this.forceFallback)
          this.toggleFallback(!1);
        else if (!this.prefix)
          (document.cancelFullScreen || document.exitFullscreen).call(document);
        else if (!r.empty(this.prefix)) {
          const t = this.prefix === "moz" ? "Cancel" : "Exit";
          document[`${this.prefix}${t}${this.property}`]();
        }
      }
    });
    // Toggle state
    f(this, "toggle", () => {
      this.active ? this.exit() : this.enter();
    });
    this.player = t, this.prefix = U.prefix, this.property = U.property, this.scrollPosition = { x: 0, y: 0 }, this.forceFallback = t.config.fullscreen.fallback === "force", this.player.elements.fullscreen = t.config.fullscreen.container && Jt(this.player.elements.container, t.config.fullscreen.container), E.call(
      this.player,
      document,
      this.prefix === "ms" ? "MSFullscreenChange" : `${this.prefix}fullscreenchange`,
      () => {
        this.onChange();
      }
    ), E.call(this.player, this.player.elements.container, "dblclick", (i) => {
      r.element(this.player.elements.controls) && this.player.elements.controls.contains(i.target) || this.player.listeners.proxy(i, this.toggle, "fullscreen");
    }), E.call(this, this.player.elements.container, "keydown", (i) => this.trapFocus(i)), this.update();
  }
  // Determine if native supported
  static get nativeSupported() {
    return !!(document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled);
  }
  // If we're actually using native
  get useNative() {
    return U.nativeSupported && !this.forceFallback;
  }
  // Get the prefix for handlers
  static get prefix() {
    if (r.function(document.exitFullscreen)) return "";
    let t = "";
    return ["webkit", "moz", "ms"].some((n) => r.function(document[`${n}ExitFullscreen`]) || r.function(document[`${n}CancelFullScreen`]) ? (t = n, !0) : !1), t;
  }
  static get property() {
    return this.prefix === "moz" ? "FullScreen" : "Fullscreen";
  }
  // Determine if fullscreen is supported
  get supported() {
    return [
      // Fullscreen is enabled in config
      this.player.config.fullscreen.enabled,
      // Must be a video
      this.player.isVideo,
      // Either native is supported or fallback enabled
      U.nativeSupported || this.player.config.fullscreen.fallback,
      // YouTube has no way to trigger fullscreen, so on devices with no native support, playsinline
      // must be enabled and iosNative fullscreen must be disabled to offer the fullscreen fallback
      !this.player.isYouTube || U.nativeSupported || !j.isIos || this.player.config.playsinline && !this.player.config.fullscreen.iosNative
    ].every(Boolean);
  }
  // Get active state
  get active() {
    if (!this.supported) return !1;
    if (!U.nativeSupported || this.forceFallback)
      return pe(this.target, this.player.config.classNames.fullscreen.fallback);
    const t = this.prefix ? this.target.getRootNode()[`${this.prefix}${this.property}Element`] : this.target.getRootNode().fullscreenElement;
    return t && t.shadowRoot ? t === this.target.getRootNode().host : t === this.target;
  }
  // Get target element
  get target() {
    return j.isIos && this.player.config.fullscreen.iosNative ? this.player.media : this.player.elements.fullscreen ?? this.player.elements.container;
  }
}
function de(e, t = 1) {
  return new Promise((i, n) => {
    const s = new Image(), a = () => {
      delete s.onload, delete s.onerror, (s.naturalWidth >= t ? i : n)(s);
    };
    Object.assign(s, { onload: a, onerror: a, src: e });
  });
}
const L = {
  addStyleHook() {
    P(this.elements.container, this.config.selectors.container.replace(".", ""), !0), P(this.elements.container, this.config.classNames.uiSupported, this.supported.ui);
  },
  // Toggle native HTML5 media controls
  toggleNativeControls(e = !1) {
    e && this.isHTML5 ? this.media.setAttribute("controls", "") : this.media.removeAttribute("controls");
  },
  // Setup the UI
  build() {
    if (this.listeners.media(), !this.supported.ui) {
      this.debug.warn(`Basic support only for ${this.provider} ${this.type}`), L.toggleNativeControls.call(this, !0);
      return;
    }
    r.element(this.elements.controls) || (p.inject.call(this), this.listeners.controls()), L.toggleNativeControls.call(this), this.isHTML5 && S.setup.call(this), this.volume = null, this.muted = null, this.loop = null, this.quality = null, this.speed = null, p.updateVolume.call(this), p.timeUpdate.call(this), p.durationUpdate.call(this), L.checkPlaying.call(this), P(
      this.elements.container,
      this.config.classNames.pip.supported,
      O.pip && this.isHTML5 && this.isVideo
    ), P(this.elements.container, this.config.classNames.airplay.supported, O.airplay && this.isHTML5), P(this.elements.container, this.config.classNames.isTouch, this.touch), this.ready = !0, setTimeout(() => {
      k.call(this, this.media, "ready");
    }, 0), L.setTitle.call(this), this.poster && L.setPoster.call(this, this.poster, !1).catch(() => {
    }), this.config.duration && p.durationUpdate.call(this), this.config.mediaMetadata && p.setMediaMetadata.call(this);
  },
  // Setup aria attribute for play and iframe title
  setTitle() {
    let e = H.get("play", this.config);
    if (r.string(this.config.title) && !r.empty(this.config.title) && (e += `, ${this.config.title}`), Array.from(this.elements.buttons.play || []).forEach((t) => {
      t.setAttribute("aria-label", e);
    }), this.isEmbed) {
      const t = _.call(this, "iframe");
      if (!r.element(t))
        return;
      const i = r.empty(this.config.title) ? "video" : this.config.title, n = H.get("frameTitle", this.config);
      t.setAttribute("title", n.replace("{title}", i));
    }
  },
  // Toggle poster
  togglePoster(e) {
    P(this.elements.container, this.config.classNames.posterEnabled, e);
  },
  // Set the poster image (async)
  // Used internally for the poster setter, with the passive option forced to false
  setPoster(e, t = !0) {
    return t && this.poster ? Promise.reject(new Error("Poster already set")) : (this.media.setAttribute("data-poster", e), this.elements.poster.removeAttribute("hidden"), ti.call(this).then(() => de(e)).catch((i) => {
      throw e === this.poster && L.togglePoster.call(this, !1), i;
    }).then(() => {
      if (e !== this.poster)
        throw new Error("setPoster cancelled by later call to setPoster");
    }).then(() => (Object.assign(this.elements.poster.style, {
      backgroundImage: `url('${e}')`,
      // Reset backgroundSize as well (since it can be set to "cover" for padded thumbnails for youtube)
      backgroundSize: ""
    }), L.togglePoster.call(this, !0), e)));
  },
  // Check playing state
  checkPlaying(e) {
    P(this.elements.container, this.config.classNames.playing, this.playing), P(this.elements.container, this.config.classNames.paused, this.paused), P(this.elements.container, this.config.classNames.stopped, this.stopped), Array.from(this.elements.buttons.play || []).forEach((t) => {
      Object.assign(t, { pressed: this.playing }), t.setAttribute("aria-label", H.get(this.playing ? "pause" : "play", this.config));
    }), !(r.event(e) && e.type === "timeupdate") && L.toggleControls.call(this);
  },
  // Check if media is loading
  checkLoading(e) {
    this.loading = ["stalled", "waiting"].includes(e.type), clearTimeout(this.timers.loading), this.timers.loading = setTimeout(
      () => {
        P(this.elements.container, this.config.classNames.loading, this.loading), L.toggleControls.call(this);
      },
      this.loading ? 250 : 0
    );
  },
  // Toggle controls based on state and `force` argument
  toggleControls(e) {
    const { controls: t } = this.elements;
    if (t && this.config.hideControls) {
      const i = this.touch && this.lastSeekTime + 2e3 > Date.now();
      this.toggleControls(
        !!(e || this.loading || this.paused || t.pressed || t.hover || i)
      );
    }
  },
  // Migrate any custom properties from the media to the parent
  migrateStyles() {
    Object.values({ ...this.media.style }).filter((e) => !r.empty(e) && r.string(e) && e.startsWith("--plyr")).forEach((e) => {
      this.elements.container.style.setProperty(e, this.media.style.getPropertyValue(e)), this.media.style.removeProperty(e);
    }), r.empty(this.media.style) && this.media.removeAttribute("style");
  }
};
class bi {
  constructor(t) {
    // Device is touch enabled
    f(this, "firstTouch", () => {
      const { player: t } = this, { elements: i } = t;
      t.touch = !0, P(i.container, t.config.classNames.isTouch, !0);
    });
    // Global window & document listeners
    f(this, "global", (t = !0) => {
      const { player: i } = this;
      i.config.keyboard.global && se.call(i, window, "keydown keyup", this.handleKey, t, !1), se.call(i, document.body, "click", this.toggleMenu, t), Ie.call(i, document.body, "touchstart", this.firstTouch);
    });
    // Container listeners
    f(this, "container", () => {
      const { player: t } = this, { config: i, elements: n, timers: s } = t;
      !i.keyboard.global && i.keyboard.focused && E.call(t, n.container, "keydown keyup", this.handleKey, !1), E.call(
        t,
        n.container,
        "mousemove mouseleave touchstart touchmove enterfullscreen exitfullscreen",
        (l) => {
          const { controls: c } = n;
          c && l.type === "enterfullscreen" && (c.pressed = !1, c.hover = !1);
          const u = ["touchstart", "touchmove", "mousemove"].includes(l.type);
          let m = 0;
          u && (L.toggleControls.call(t, !0), m = t.touch ? 3e3 : 2e3), clearTimeout(s.controls), s.controls = setTimeout(() => L.toggleControls.call(t, !1), m);
        }
      );
      const a = () => {
        if (!t.isVimeo || t.config.vimeo.premium)
          return;
        const l = n.wrapper, { active: c } = t.fullscreen, [u, m] = Oe.call(t), b = ot(`aspect-ratio: ${u} / ${m}`);
        if (!c) {
          b ? (l.style.width = null, l.style.height = null) : (l.style.maxWidth = null, l.style.margin = null);
          return;
        }
        const [d, h] = ii(), y = d / h > u / m;
        b ? (l.style.width = y ? "auto" : "100%", l.style.height = y ? "100%" : "auto") : (l.style.maxWidth = y ? `${h / m * u}px` : null, l.style.margin = y ? "0 auto" : null);
      }, o = () => {
        clearTimeout(s.resized), s.resized = setTimeout(a, 50);
      };
      E.call(t, n.container, "enterfullscreen exitfullscreen", (l) => {
        const { target: c } = t.fullscreen;
        if (c !== n.container || !t.isEmbed && r.empty(t.config.ratio))
          return;
        a(), (l.type === "enterfullscreen" ? E : be).call(t, window, "resize", o);
      });
    });
    // Listen for media events
    f(this, "media", () => {
      const { player: t } = this, { elements: i } = t;
      if (E.call(t, t.media, "timeupdate seeking seeked", (s) => p.timeUpdate.call(t, s)), E.call(t, t.media, "durationchange loadeddata loadedmetadata", (s) => p.durationUpdate.call(t, s)), E.call(t, t.media, "ended", () => {
        t.isHTML5 && t.isVideo && t.config.resetOnEnd && (t.restart(), t.pause());
      }), E.call(t, t.media, "progress playing seeking seeked", (s) => p.updateProgress.call(t, s)), E.call(t, t.media, "volumechange", (s) => p.updateVolume.call(t, s)), E.call(t, t.media, "playing play pause ended emptied timeupdate", (s) => L.checkPlaying.call(t, s)), E.call(t, t.media, "waiting canplay seeked playing", (s) => L.checkLoading.call(t, s)), t.supported.ui && t.config.clickToPlay && !t.isAudio) {
        const s = _.call(t, `.${t.config.classNames.video}`);
        if (!r.element(s))
          return;
        E.call(t, i.container, "click", (a) => {
          ![i.container, s].includes(a.target) && !s.contains(a.target) || t.touch && t.config.hideControls || (t.ended ? (this.proxy(a, t.restart, "restart"), this.proxy(
            a,
            () => {
              W(t.play());
            },
            "play"
          )) : this.proxy(
            a,
            () => {
              W(t.togglePlay());
            },
            "play"
          ));
        });
      }
      t.supported.ui && t.config.disableContextMenu && E.call(
        t,
        i.wrapper,
        "contextmenu",
        (s) => {
          s.preventDefault();
        },
        !1
      ), E.call(t, t.media, "volumechange", () => {
        t.storage.set({
          volume: t.volume,
          muted: t.muted
        });
      }), E.call(t, t.media, "ratechange", () => {
        p.updateSetting.call(t, "speed"), t.storage.set({ speed: t.speed });
      }), E.call(t, t.media, "qualitychange", (s) => {
        p.updateSetting.call(t, "quality", null, s.detail.quality);
      }), E.call(t, t.media, "ready qualitychange", () => {
        p.setDownloadUrl.call(t);
      });
      const n = t.config.events.concat(["keyup", "keydown"]).join(" ");
      E.call(t, t.media, n, (s) => {
        let { detail: a = {} } = s;
        s.type === "error" && (a = t.media.error), k.call(t, i.container, s.type, !0, a);
      });
    });
    // Run default and custom handlers
    f(this, "proxy", (t, i, n) => {
      const { player: s } = this, a = s.config.listeners[n], o = r.function(a);
      let l = !0;
      o && (l = a.call(s, t)), l !== !1 && r.function(i) && i.call(s, t);
    });
    // Trigger custom and default handlers
    f(this, "bind", (t, i, n, s, a = !0) => {
      const { player: o } = this, l = o.config.listeners[s], c = r.function(l);
      E.call(
        o,
        t,
        i,
        (u) => this.proxy(u, n, s),
        a && !c
      );
    });
    // Listen for control events
    f(this, "controls", () => {
      const { player: t } = this, { elements: i } = t, n = j.isIE ? "change" : "input";
      if (i.buttons.play && Array.from(i.buttons.play).forEach((s) => {
        this.bind(
          s,
          "click",
          () => {
            W(t.togglePlay());
          },
          "play"
        );
      }), this.bind(i.buttons.restart, "click", t.restart, "restart"), this.bind(
        i.buttons.rewind,
        "click",
        () => {
          t.lastSeekTime = Date.now(), t.rewind();
        },
        "rewind"
      ), this.bind(
        i.buttons.fastForward,
        "click",
        () => {
          t.lastSeekTime = Date.now(), t.forward();
        },
        "fastForward"
      ), this.bind(
        i.buttons.mute,
        "click",
        () => {
          t.muted = !t.muted;
        },
        "mute"
      ), this.bind(i.buttons.captions, "click", () => t.toggleCaptions()), this.bind(
        i.buttons.download,
        "click",
        () => {
          k.call(t, t.media, "download");
        },
        "download"
      ), this.bind(
        i.buttons.fullscreen,
        "click",
        () => {
          t.fullscreen.toggle();
        },
        "fullscreen"
      ), this.bind(
        i.buttons.pip,
        "click",
        () => {
          t.pip = "toggle";
        },
        "pip"
      ), this.bind(i.buttons.airplay, "click", t.airplay, "airplay"), this.bind(
        i.buttons.settings,
        "click",
        (s) => {
          s.stopPropagation(), s.preventDefault(), p.toggleMenu.call(t, s);
        },
        null,
        !1
      ), this.bind(
        i.buttons.settings,
        "keyup",
        (s) => {
          if ([" ", "Enter"].includes(s.key)) {
            if (s.key === "Enter") {
              p.focusFirstMenuItem.call(t, null, !0);
              return;
            }
            s.preventDefault(), s.stopPropagation(), p.toggleMenu.call(t, s);
          }
        },
        null,
        !1
        // Can't be passive as we're preventing default
      ), this.bind(i.settings.menu, "keydown", (s) => {
        s.key === "Escape" && p.toggleMenu.call(t, s);
      }), this.bind(i.inputs.seek, "mousedown mousemove", (s) => {
        const a = i.progress.getBoundingClientRect(), o = s.pageX - s.clientX, l = 100 / a.width * (s.pageX - a.left - o);
        s.currentTarget.setAttribute("seek-value", l);
      }), this.bind(i.inputs.seek, "mousedown mouseup keydown keyup touchstart touchend", (s) => {
        const a = s.currentTarget, o = "play-on-seeked";
        if (r.keyboardEvent(s) && !["ArrowLeft", "ArrowRight"].includes(s.key))
          return;
        t.lastSeekTime = Date.now();
        const l = a.hasAttribute(o), c = ["mouseup", "touchend", "keyup"].includes(s.type);
        l && c ? (a.removeAttribute(o), W(t.play())) : !c && t.playing && (a.setAttribute(o, ""), t.pause());
      }), j.isIos) {
        const s = ie.call(t, 'input[type="range"]');
        Array.from(s).forEach((a) => this.bind(a, n, (o) => st(o.target)));
      }
      this.bind(
        i.inputs.seek,
        n,
        (s) => {
          const a = s.currentTarget;
          let o = a.getAttribute("seek-value");
          r.empty(o) && (o = a.value), a.removeAttribute("seek-value"), t.currentTime = o / a.max * t.duration;
        },
        "seek"
      ), this.bind(i.progress, "mouseenter mouseleave mousemove", (s) => p.updateSeekTooltip.call(t, s)), this.bind(i.progress, "mousemove touchmove", (s) => {
        const { previewThumbnails: a } = t;
        a && a.loaded && a.startMove(s);
      }), this.bind(i.progress, "mouseleave touchend click", () => {
        const { previewThumbnails: s } = t;
        s && s.loaded && s.endMove(!1, !0);
      }), this.bind(i.progress, "mousedown touchstart", (s) => {
        const { previewThumbnails: a } = t;
        a && a.loaded && a.startScrubbing(s);
      }), this.bind(i.progress, "mouseup touchend", (s) => {
        const { previewThumbnails: a } = t;
        a && a.loaded && a.endScrubbing(s);
      }), j.isWebKit && Array.from(ie.call(t, 'input[type="range"]')).forEach((s) => {
        this.bind(s, "input", (a) => p.updateRangeFill.call(t, a.target));
      }), t.config.toggleInvert && !r.element(i.display.duration) && this.bind(i.display.currentTime, "click", () => {
        t.currentTime !== 0 && (t.config.invertTime = !t.config.invertTime, p.timeUpdate.call(t));
      }), this.bind(
        i.inputs.volume,
        n,
        (s) => {
          t.volume = s.target.value;
        },
        "volume"
      ), this.bind(i.controls, "mouseenter mouseleave", (s) => {
        i.controls.hover = !t.touch && s.type === "mouseenter";
      }), i.fullscreen && Array.from(i.fullscreen.children).filter((s) => !s.contains(i.container)).forEach((s) => {
        this.bind(s, "mouseenter mouseleave", (a) => {
          i.controls && (i.controls.hover = !t.touch && a.type === "mouseenter");
        });
      }), this.bind(i.controls, "mousedown mouseup touchstart touchend touchcancel", (s) => {
        i.controls.pressed = ["mousedown", "touchstart"].includes(s.type);
      }), this.bind(i.controls, "focusin", () => {
        const { config: s, timers: a } = t;
        P(i.controls, s.classNames.noTransition, !0), L.toggleControls.call(t, !0), setTimeout(() => {
          P(i.controls, s.classNames.noTransition, !1);
        }, 0);
        const o = this.touch ? 3e3 : 4e3;
        clearTimeout(a.controls), a.controls = setTimeout(() => L.toggleControls.call(t, !1), o);
      }), this.bind(
        i.inputs.volume,
        "wheel",
        (s) => {
          const a = s.webkitDirectionInvertedFromDevice, [o, l] = [s.deltaX, -s.deltaY].map((m) => a ? -m : m), c = Math.sign(Math.abs(o) > Math.abs(l) ? o : l);
          t.increaseVolume(c / 50);
          const { volume: u } = t.media;
          (c === 1 && u < 1 || c === -1 && u > 0) && s.preventDefault();
        },
        "volume",
        !1
      );
    });
    this.player = t, this.lastKey = null, this.focusTimer = null, this.lastKeyDown = null, this.handleKey = this.handleKey.bind(this), this.toggleMenu = this.toggleMenu.bind(this), this.firstTouch = this.firstTouch.bind(this);
  }
  // Handle key presses
  handleKey(t) {
    const { player: i } = this, { elements: n } = i, { key: s, type: a, altKey: o, ctrlKey: l, metaKey: c, shiftKey: u } = t, m = a === "keydown", b = m && s === this.lastKey;
    if (o || l || c || u || !s)
      return;
    const d = (h) => {
      i.currentTime = i.duration / 10 * h;
    };
    if (m) {
      const h = document.activeElement;
      if (r.element(h)) {
        const { editable: w } = i.config.selectors, { seek: T } = n.inputs;
        if (h !== T && G(h, w) || t.key === " " && G(h, 'button, [role^="menuitem"]'))
          return;
      }
      switch ([
        " ",
        "ArrowLeft",
        "ArrowUp",
        "ArrowRight",
        "ArrowDown",
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "c",
        "f",
        "k",
        "l",
        "m"
      ].includes(s) && (t.preventDefault(), t.stopPropagation()), s) {
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          b || d(Number.parseInt(s, 10));
          break;
        case " ":
        case "k":
          b || W(i.togglePlay());
          break;
        case "ArrowUp":
          i.increaseVolume(0.1);
          break;
        case "ArrowDown":
          i.decreaseVolume(0.1);
          break;
        case "m":
          b || (i.muted = !i.muted);
          break;
        case "ArrowRight":
          i.forward();
          break;
        case "ArrowLeft":
          i.rewind();
          break;
        case "f":
          i.fullscreen.toggle();
          break;
        case "c":
          b || i.toggleCaptions();
          break;
        case "l":
          i.loop = !i.loop;
          break;
      }
      s === "Escape" && !i.fullscreen.usingNative && i.fullscreen.active && i.fullscreen.toggle(), this.lastKey = s;
    } else
      this.lastKey = null;
  }
  // Toggle menu
  toggleMenu(t) {
    p.toggleMenu.call(this.player, t);
  }
}
var wi = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function vi(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var gt = { exports: {} };
(function(e, t) {
  (function(i, n) {
    e.exports = n();
  })(wi, function() {
    var i = function() {
    }, n = {}, s = {}, a = {};
    function o(d, h) {
      d = d.push ? d : [d];
      var y = [], w = d.length, T = w, A, g, C, $;
      for (A = function(D, N) {
        N.length && y.push(D), T--, T || h(y);
      }; w--; ) {
        if (g = d[w], C = s[g], C) {
          A(g, C);
          continue;
        }
        $ = a[g] = a[g] || [], $.push(A);
      }
    }
    function l(d, h) {
      if (d) {
        var y = a[d];
        if (s[d] = h, !!y)
          for (; y.length; )
            y[0](d, h), y.splice(0, 1);
      }
    }
    function c(d, h) {
      d.call && (d = { success: d }), h.length ? (d.error || i)(h) : (d.success || i)(d);
    }
    function u(d, h, y, w) {
      var T = document, A = y.async, g = (y.numRetries || 0) + 1, C = y.before || i, $ = d.replace(/[\?|#].*$/, ""), D = d.replace(/^(css|img|module|nomodule)!/, ""), N, M, x;
      if (w = w || 0, /(^css!|\.css$)/.test($))
        x = T.createElement("link"), x.rel = "stylesheet", x.href = D, N = "hideFocus" in x, N && x.relList && (N = 0, x.rel = "preload", x.as = "style");
      else if (/(^img!|\.(png|gif|jpg|svg|webp)$)/.test($))
        x = T.createElement("img"), x.src = D;
      else if (x = T.createElement("script"), x.src = D, x.async = A === void 0 ? !0 : A, M = "noModule" in x, /^module!/.test($)) {
        if (!M) return h(d, "l");
        x.type = "module";
      } else if (/^nomodule!/.test($) && M) return h(d, "l");
      x.onload = x.onerror = x.onbeforeload = function(He) {
        var ce = He.type[0];
        if (N)
          try {
            x.sheet.cssText.length || (ce = "e");
          } catch (Tt) {
            Tt.code != 18 && (ce = "e");
          }
        if (ce == "e") {
          if (w += 1, w < g)
            return u(d, h, y, w);
        } else if (x.rel == "preload" && x.as == "style")
          return x.rel = "stylesheet";
        h(d, ce, He.defaultPrevented);
      }, C(d, x) !== !1 && T.head.appendChild(x);
    }
    function m(d, h, y) {
      d = d.push ? d : [d];
      var w = d.length, T = w, A = [], g, C;
      for (g = function($, D, N) {
        if (D == "e" && A.push($), D == "b")
          if (N) A.push($);
          else return;
        w--, w || h(A);
      }, C = 0; C < T; C++) u(d[C], g, y);
    }
    function b(d, h, y) {
      var w, T;
      if (h && h.trim && (w = h), T = (w ? y : h) || {}, w) {
        if (w in n)
          throw "LoadJS";
        n[w] = !0;
      }
      function A(g, C) {
        m(d, function($) {
          c(T, $), g && c({ success: g, error: C }, $), l(w, $);
        }, T);
      }
      if (T.returnPromise) return new Promise(A);
      A();
    }
    return b.ready = function(h, y) {
      return o(h, function(w) {
        c(y, w);
      }), b;
    }, b.done = function(h) {
      l(h, []);
    }, b.reset = function() {
      n = {}, s = {}, a = {};
    }, b.isDefined = function(h) {
      return h in n;
    }, b;
  });
})(gt);
var ki = gt.exports;
const Ti = /* @__PURE__ */ vi(ki);
function _e(e) {
  return new Promise((t, i) => {
    Ti(e, {
      success: t,
      error: i
    });
  });
}
function Ci(e) {
  if (r.empty(e))
    return null;
  if (r.number(Number(e)))
    return e;
  const t = /^.*(vimeo.com\/|video\/)(\d+).*/, i = e.match(t);
  return i ? i[2] : e;
}
function Ei(e) {
  const t = /^.*(vimeo.com\/|video\/)(\d+)(\?.*h=|\/)+([\d,a-f]+)/, i = e.match(t);
  return i && i.length === 5 ? i[4] : null;
}
function Z(e) {
  e && !this.embed.hasPlayed && (this.embed.hasPlayed = !0), this.media.paused === e && (this.media.paused = !e, k.call(this, this.media, e ? "play" : "pause"));
}
const Me = {
  setup() {
    const e = this;
    P(e.elements.wrapper, e.config.classNames.embed, !0), e.options.speed = e.config.speed.options, J.call(e), r.object(window.Vimeo) ? Me.ready.call(e) : _e(e.config.urls.vimeo.sdk).then(() => {
      Me.ready.call(e);
    }).catch((t) => {
      e.debug.warn("Vimeo SDK (player.js) failed to load", t);
    });
  },
  // API Ready
  ready() {
    const e = this, t = e.config.vimeo, { premium: i, referrerPolicy: n, ...s } = t;
    let a = e.media.getAttribute("src"), o = "";
    r.empty(a) ? (a = e.media.getAttribute(e.config.attributes.embed.id), o = e.media.getAttribute(e.config.attributes.embed.hash)) : o = Ei(a);
    const l = o ? { h: o } : {};
    i && Object.assign(s, {
      controls: !1,
      sidedock: !1
    });
    const c = pt({
      loop: e.config.loop.active,
      autoplay: e.autoplay,
      muted: e.muted,
      gesture: "media",
      playsinline: e.config.playsinline,
      // hash has to be added to iframe-URL
      ...l,
      ...s
    }), u = Ci(a), m = v("iframe"), b = Pe(e.config.urls.vimeo.iframe, u, c);
    if (m.setAttribute("src", b), m.setAttribute("allowfullscreen", ""), m.setAttribute(
      "allow",
      ["autoplay", "fullscreen", "picture-in-picture", "encrypted-media", "accelerometer", "gyroscope"].join("; ")
    ), r.empty(n) || m.setAttribute("referrerPolicy", n), i || !t.customControls)
      m.setAttribute("data-poster", e.poster), e.media = me(m, e.media);
    else {
      const g = v("div", {
        class: e.config.classNames.embedContainer,
        "data-poster": e.poster
      });
      g.appendChild(m), e.media = me(g, e.media);
    }
    t.customControls || le(Pe(e.config.urls.vimeo.api, b)).then((g) => {
      r.empty(g) || !g.thumbnail_url || L.setPoster.call(e, g.thumbnail_url).catch(() => {
      });
    }), e.embed = new window.Vimeo.Player(m, {
      autopause: e.config.autopause,
      muted: e.muted
    }), e.media.paused = !0, e.media.currentTime = 0, e.supported.ui && e.embed.disableTextTrack(), e.media.play = () => (Z.call(e, !0), e.embed.play()), e.media.pause = () => (Z.call(e, !1), e.embed.pause()), e.media.stop = () => {
      e.pause(), e.currentTime = 0;
    };
    let { currentTime: d } = e.media;
    Object.defineProperty(e.media, "currentTime", {
      get() {
        return d;
      },
      set(g) {
        const { embed: C, media: $, paused: D, volume: N } = e, M = D && !C.hasPlayed;
        $.seeking = !0, k.call(e, $, "seeking"), Promise.resolve(M && C.setVolume(0)).then(() => C.setCurrentTime(g)).then(() => M && C.pause()).then(() => M && C.setVolume(N)).catch(() => {
        });
      }
    });
    let h = e.config.speed.selected;
    Object.defineProperty(e.media, "playbackRate", {
      get() {
        return h;
      },
      set(g) {
        e.embed.setPlaybackRate(g).then(() => {
          h = g, k.call(e, e.media, "ratechange");
        }).catch(() => {
          e.options.speed = [1];
        });
      }
    });
    let { volume: y } = e.config;
    Object.defineProperty(e.media, "volume", {
      get() {
        return y;
      },
      set(g) {
        e.embed.setVolume(g).then(() => {
          y = g, k.call(e, e.media, "volumechange");
        });
      }
    });
    let { muted: w } = e.config;
    Object.defineProperty(e.media, "muted", {
      get() {
        return w;
      },
      set(g) {
        const C = r.boolean(g) ? g : !1;
        e.embed.setMuted(C ? !0 : e.config.muted).then(() => {
          w = C, k.call(e, e.media, "volumechange");
        });
      }
    });
    let { loop: T } = e.config;
    Object.defineProperty(e.media, "loop", {
      get() {
        return T;
      },
      set(g) {
        const C = r.boolean(g) ? g : e.config.loop.active;
        e.embed.setLoop(C).then(() => {
          T = C;
        });
      }
    });
    let A;
    e.embed.getVideoUrl().then((g) => {
      A = g, p.setDownloadUrl.call(e);
    }).catch((g) => {
      this.debug.warn(g);
    }), Object.defineProperty(e.media, "currentSrc", {
      get() {
        return A;
      }
    }), Object.defineProperty(e.media, "ended", {
      get() {
        return e.currentTime === e.duration;
      }
    }), Promise.all([e.embed.getVideoWidth(), e.embed.getVideoHeight()]).then((g) => {
      const [C, $] = g;
      e.embed.ratio = ct(C, $), J.call(this);
    }), e.embed.setAutopause(e.config.autopause).then((g) => {
      e.config.autopause = g;
    }), e.embed.getVideoTitle().then((g) => {
      e.config.title = g, L.setTitle.call(this);
    }), e.embed.getCurrentTime().then((g) => {
      d = g, k.call(e, e.media, "timeupdate");
    }), e.embed.getDuration().then((g) => {
      e.media.duration = g, k.call(e, e.media, "durationchange");
    }), e.embed.getTextTracks().then((g) => {
      e.media.textTracks = g, S.setup.call(e);
    }), e.embed.on("cuechange", ({ cues: g = [] }) => {
      const C = g.map(($) => hi($.text));
      S.updateCues.call(e, C);
    }), e.embed.on("loaded", () => {
      e.embed.getPaused().then((g) => {
        Z.call(e, !g), g || k.call(e, e.media, "playing");
      }), r.element(e.embed.element) && e.supported.ui && e.embed.element.setAttribute("tabindex", -1);
    }), e.embed.on("bufferstart", () => {
      k.call(e, e.media, "waiting");
    }), e.embed.on("bufferend", () => {
      k.call(e, e.media, "playing");
    }), e.embed.on("play", () => {
      Z.call(e, !0), k.call(e, e.media, "playing");
    }), e.embed.on("pause", () => {
      Z.call(e, !1);
    }), e.embed.on("timeupdate", (g) => {
      e.media.seeking = !1, d = g.seconds, k.call(e, e.media, "timeupdate");
    }), e.embed.on("progress", (g) => {
      e.media.buffered = g.percent, k.call(e, e.media, "progress"), Number.parseInt(g.percent, 10) === 1 && k.call(e, e.media, "canplaythrough"), e.embed.getDuration().then((C) => {
        C !== e.media.duration && (e.media.duration = C, k.call(e, e.media, "durationchange"));
      });
    }), e.embed.on("seeked", () => {
      e.media.seeking = !1, k.call(e, e.media, "seeked");
    }), e.embed.on("ended", () => {
      e.media.paused = !0, k.call(e, e.media, "ended");
    }), e.embed.on("error", (g) => {
      e.media.error = g, k.call(e, e.media, "error");
    }), t.customControls && setTimeout(() => L.build.call(e), 0);
  }
};
function Ai(e) {
  if (r.empty(e))
    return null;
  const t = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/, i = e.match(t);
  return i && i[2] ? i[2] : e;
}
function ee(e) {
  e && !this.embed.hasPlayed && (this.embed.hasPlayed = !0), this.media.paused === e && (this.media.paused = !e, k.call(this, this.media, e ? "play" : "pause"));
}
function Si(e) {
  if (e.noCookie)
    return "https://www.youtube-nocookie.com";
  if (window.location.protocol === "http:")
    return "http://www.youtube.com";
}
const he = {
  setup() {
    if (P(this.elements.wrapper, this.config.classNames.embed, !0), r.object(window.YT) && r.function(window.YT.Player))
      he.ready.call(this);
    else {
      const e = window.onYouTubeIframeAPIReady;
      window.onYouTubeIframeAPIReady = () => {
        r.function(e) && e(), he.ready.call(this);
      }, _e(this.config.urls.youtube.sdk).catch((t) => {
        this.debug.warn("YouTube API failed to load", t);
      });
    }
  },
  // Get the media title
  getTitle(e) {
    const t = Pe(this.config.urls.youtube.api, e);
    le(t).then((i) => {
      if (r.object(i)) {
        const { title: n, height: s, width: a } = i;
        this.config.title = n, L.setTitle.call(this), this.embed.ratio = ct(a, s);
      }
      J.call(this);
    }).catch(() => {
      J.call(this);
    });
  },
  // API ready
  ready() {
    const e = this, t = e.config.youtube, i = e.media && e.media.getAttribute("id");
    if (!r.empty(i) && i.startsWith("youtube-"))
      return;
    let n = e.media.getAttribute("src");
    r.empty(n) && (n = e.media.getAttribute(this.config.attributes.embed.id));
    const s = Ai(n), a = li(e.provider), o = v("div", { id: a, "data-poster": t.customControls ? e.poster : void 0 });
    if (e.media = me(o, e.media), t.customControls) {
      const l = (c) => `https://i.ytimg.com/vi/${s}/${c}default.jpg`;
      de(l("maxres"), 121).catch(() => de(l("sd"), 121)).catch(() => de(l("hq"))).then((c) => L.setPoster.call(e, c.src)).then((c) => {
        c.includes("maxres") || (e.elements.poster.style.backgroundSize = "cover");
      }).catch(() => {
      });
    }
    e.embed = new window.YT.Player(e.media, {
      videoId: s,
      host: Si(t),
      playerVars: I(
        {},
        {
          // Autoplay
          autoplay: e.config.autoplay ? 1 : 0,
          // iframe interface language
          hl: e.config.hl,
          // Only show controls if not fully supported or opted out
          controls: e.supported.ui && t.customControls ? 0 : 1,
          // Disable keyboard as we handle it
          disablekb: 1,
          // Allow iOS inline playback
          playsinline: e.config.playsinline && !e.config.fullscreen.iosNative ? 1 : 0,
          // Captions are flaky on YouTube
          cc_load_policy: e.captions.active ? 1 : 0,
          cc_lang_pref: e.config.captions.language,
          // Tracking for stats
          widget_referrer: window ? window.location.href : null
        },
        t
      ),
      events: {
        onError(l) {
          if (!e.media.error) {
            const c = l.data, u = {
              2: "The request contains an invalid parameter value. For example, this error occurs if you specify a video ID that does not have 11 characters, or if the video ID contains invalid characters, such as exclamation points or asterisks.",
              5: "The requested content cannot be played in an HTML5 player or another error related to the HTML5 player has occurred.",
              100: "The video requested was not found. This error occurs when a video has been removed (for any reason) or has been marked as private.",
              101: "The owner of the requested video does not allow it to be played in embedded players.",
              150: "The owner of the requested video does not allow it to be played in embedded players."
            }[c] || "An unknown error occurred";
            e.media.error = { code: c, message: u }, k.call(e, e.media, "error");
          }
        },
        onPlaybackRateChange(l) {
          const c = l.target;
          e.media.playbackRate = c.getPlaybackRate(), k.call(e, e.media, "ratechange");
        },
        onReady(l) {
          if (r.function(e.media.play))
            return;
          const c = l.target;
          he.getTitle.call(e, s), e.media.play = () => {
            ee.call(e, !0), c.playVideo();
          }, e.media.pause = () => {
            ee.call(e, !1), c.pauseVideo();
          }, e.media.stop = () => {
            c.stopVideo();
          }, e.media.duration = c.getDuration(), e.media.paused = !0, e.media.currentTime = 0, Object.defineProperty(e.media, "currentTime", {
            get() {
              return Number(c.getCurrentTime());
            },
            set(d) {
              e.paused && !e.embed.hasPlayed && e.embed.mute(), e.media.seeking = !0, k.call(e, e.media, "seeking"), c.seekTo(d);
            }
          }), Object.defineProperty(e.media, "playbackRate", {
            get() {
              return c.getPlaybackRate();
            },
            set(d) {
              c.setPlaybackRate(d);
            }
          });
          let { volume: u } = e.config;
          Object.defineProperty(e.media, "volume", {
            get() {
              return u;
            },
            set(d) {
              u = d, c.setVolume(u * 100), k.call(e, e.media, "volumechange");
            }
          });
          let { muted: m } = e.config;
          Object.defineProperty(e.media, "muted", {
            get() {
              return m;
            },
            set(d) {
              const h = r.boolean(d) ? d : m;
              m = h, c[h ? "mute" : "unMute"](), c.setVolume(u * 100), k.call(e, e.media, "volumechange");
            }
          }), Object.defineProperty(e.media, "currentSrc", {
            get() {
              return c.getVideoUrl();
            }
          }), Object.defineProperty(e.media, "ended", {
            get() {
              return e.currentTime === e.duration;
            }
          });
          const b = c.getAvailablePlaybackRates();
          e.options.speed = b.filter((d) => e.config.speed.options.includes(d)), e.supported.ui && t.customControls && e.media.setAttribute("tabindex", -1), k.call(e, e.media, "timeupdate"), k.call(e, e.media, "durationchange"), clearInterval(e.timers.buffering), e.timers.buffering = setInterval(() => {
            e.media.buffered = c.getVideoLoadedFraction(), (e.media.lastBuffered === null || e.media.lastBuffered < e.media.buffered) && k.call(e, e.media, "progress"), e.media.lastBuffered = e.media.buffered, e.media.buffered === 1 && (clearInterval(e.timers.buffering), k.call(e, e.media, "canplaythrough"));
          }, 200), t.customControls && setTimeout(() => L.build.call(e), 50);
        },
        onStateChange(l) {
          const c = l.target;
          switch (clearInterval(e.timers.playing), e.media.seeking && [1, 2].includes(l.data) && (e.media.seeking = !1, k.call(e, e.media, "seeked")), l.data) {
            case -1:
              k.call(e, e.media, "timeupdate"), e.media.buffered = c.getVideoLoadedFraction(), k.call(e, e.media, "progress");
              break;
            case 0:
              ee.call(e, !1), e.media.loop ? (c.stopVideo(), c.playVideo()) : k.call(e, e.media, "ended");
              break;
            case 1:
              t.customControls && !e.config.autoplay && e.media.paused && !e.embed.hasPlayed ? e.media.pause() : (ee.call(e, !0), k.call(e, e.media, "playing"), e.timers.playing = setInterval(() => {
                k.call(e, e.media, "timeupdate");
              }, 50), e.media.duration !== c.getDuration() && (e.media.duration = c.getDuration(), k.call(e, e.media, "durationchange")));
              break;
            case 2:
              e.muted || e.embed.unMute(), ee.call(e, !1);
              break;
            case 3:
              k.call(e, e.media, "waiting");
              break;
          }
          k.call(e, e.elements.container, "statechange", !1, {
            code: l.data
          });
        }
      }
    });
  }
}, yt = {
  // Setup media
  setup() {
    if (!this.media) {
      this.debug.warn("No media element found!");
      return;
    }
    P(this.elements.container, this.config.classNames.type.replace("{0}", this.type), !0), P(this.elements.container, this.config.classNames.provider.replace("{0}", this.provider), !0), this.isEmbed && P(this.elements.container, this.config.classNames.type.replace("{0}", "video"), !0), this.isVideo && (this.elements.wrapper = v("div", {
      class: this.config.classNames.video
    }), rt(this.media, this.elements.wrapper), this.elements.poster = v("div", {
      class: this.config.classNames.poster
    }), this.elements.wrapper.appendChild(this.elements.poster)), this.isHTML5 ? X.setup.call(this) : this.isYouTube ? he.setup.call(this) : this.isVimeo && Me.setup.call(this);
  }
};
function Pi(e) {
  e.manager && e.manager.destroy(), e.elements.displayContainer && e.elements.displayContainer.destroy(), e.elements.container.remove();
}
class Mi {
  /**
   * Ads constructor.
   * @param {object} player
   * @return {Ads}
   */
  constructor(t) {
    /**
     * Load the IMA SDK
     */
    f(this, "load", () => {
      this.enabled && (!r.object(window.google) || !r.object(window.google.ima) ? _e(this.player.config.urls.googleIMA.sdk).then(() => {
        this.ready();
      }).catch(() => {
        this.trigger("error", new Error("Google IMA SDK failed to load"));
      }) : this.ready());
    });
    /**
     * Get the ads instance ready
     */
    f(this, "ready", () => {
      this.enabled || Pi(this), this.startSafetyTimer(12e3, "ready()"), this.managerPromise.then(() => {
        this.clearSafetyTimer("onAdsManagerLoaded()");
      }), this.listeners(), this.setupIMA();
    });
    /**
     * In order for the SDK to display ads for our video, we need to tell it where to put them,
     * so here we define our ad container. This div is set up to render on top of the video player.
     * Using the code below, we tell the SDK to render ads within that div. We also provide a
     * handle to the content video player - the SDK will poll the current time of our player to
     * properly place mid-rolls. After we create the ad display container, we initialize it. On
     * mobile devices, this initialization is done as the result of a user action.
     */
    f(this, "setupIMA", () => {
      this.elements.container = v("div", {
        class: this.player.config.classNames.ads
      }), this.player.elements.container.appendChild(this.elements.container), google.ima.settings.setVpaidMode(google.ima.ImaSdkSettings.VpaidMode.ENABLED), google.ima.settings.setLocale(this.player.config.ads.language), google.ima.settings.setDisableCustomPlaybackForIOS10Plus(this.player.config.playsinline), this.elements.displayContainer = new google.ima.AdDisplayContainer(this.elements.container, this.player.media), this.loader = new google.ima.AdsLoader(this.elements.displayContainer), this.loader.addEventListener(
        google.ima.AdsManagerLoadedEvent.Type.ADS_MANAGER_LOADED,
        (t) => this.onAdsManagerLoaded(t),
        !1
      ), this.loader.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, (t) => this.onAdError(t), !1), this.requestAds();
    });
    /**
     * Request advertisements
     */
    f(this, "requestAds", () => {
      const { container: t } = this.player.elements;
      try {
        const i = new google.ima.AdsRequest();
        i.adTagUrl = this.tagUrl, i.linearAdSlotWidth = t.offsetWidth, i.linearAdSlotHeight = t.offsetHeight, i.nonLinearAdSlotWidth = t.offsetWidth, i.nonLinearAdSlotHeight = t.offsetHeight, i.forceNonLinearFullSlot = !1, i.setAdWillPlayMuted(!this.player.muted), this.loader.requestAds(i);
      } catch (i) {
        this.onAdError(i);
      }
    });
    /**
     * Update the ad countdown
     * @param {boolean} start
     */
    f(this, "pollCountdown", (t = !1) => {
      if (!t) {
        clearInterval(this.countdownTimer), this.elements.container.removeAttribute("data-badge-text");
        return;
      }
      const i = () => {
        const n = we(Math.max(this.manager.getRemainingTime(), 0)), s = `${H.get("advertisement", this.player.config)} - ${n}`;
        this.elements.container.setAttribute("data-badge-text", s);
      };
      this.countdownTimer = setInterval(i, 100);
    });
    /**
     * This method is called whenever the ads are ready inside the AdDisplayContainer
     * @param {Event} event - adsManagerLoadedEvent
     */
    f(this, "onAdsManagerLoaded", (t) => {
      if (!this.enabled)
        return;
      const i = new google.ima.AdsRenderingSettings();
      i.restoreCustomPlaybackStateOnAdBreakComplete = !0, i.enablePreloading = !0, this.manager = t.getAdsManager(this.player, i), this.cuePoints = this.manager.getCuePoints(), this.manager.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, (n) => this.onAdError(n)), Object.keys(google.ima.AdEvent.Type).forEach((n) => {
        this.manager.addEventListener(google.ima.AdEvent.Type[n], (s) => this.onAdEvent(s));
      }), this.trigger("loaded");
    });
    f(this, "addCuePoints", () => {
      r.empty(this.cuePoints) || this.cuePoints.forEach((t) => {
        if (t !== 0 && t !== -1 && t < this.player.duration) {
          const i = this.player.elements.progress;
          if (r.element(i)) {
            const n = 100 / this.player.duration * t, s = v("span", {
              class: this.player.config.classNames.cues
            });
            s.style.left = `${n.toString()}%`, i.appendChild(s);
          }
        }
      });
    });
    /**
     * This is where all the event handling takes place. Retrieve the ad from the event. Some
     * events (e.g. ALL_ADS_COMPLETED) don't have the ad object associated
     * https://developers.google.com/interactive-media-ads/docs/sdks/html5/v3/apis#ima.AdEvent.Type
     * @param {Event} event
     */
    f(this, "onAdEvent", (t) => {
      const { container: i } = this.player.elements, n = t.getAd(), s = t.getAdData();
      switch (((o) => {
        k.call(this.player, this.player.media, `ads${o.replace(/_/g, "").toLowerCase()}`);
      })(t.type), t.type) {
        case google.ima.AdEvent.Type.LOADED:
          this.trigger("loaded"), this.pollCountdown(!0), n.isLinear() || (n.width = i.offsetWidth, n.height = i.offsetHeight);
          break;
        case google.ima.AdEvent.Type.STARTED:
          this.manager.setVolume(this.player.volume);
          break;
        case google.ima.AdEvent.Type.ALL_ADS_COMPLETED:
          this.player.ended ? this.loadAds() : this.loader.contentComplete();
          break;
        case google.ima.AdEvent.Type.CONTENT_PAUSE_REQUESTED:
          this.pauseContent();
          break;
        case google.ima.AdEvent.Type.CONTENT_RESUME_REQUESTED:
          this.pollCountdown(), this.resumeContent();
          break;
        case google.ima.AdEvent.Type.LOG:
          s.adError && this.player.debug.warn(`Non-fatal ad error: ${s.adError.getMessage()}`);
          break;
      }
    });
    /**
     * Any ad error handling comes through here
     * @param {Event} event
     */
    f(this, "onAdError", (t) => {
      this.cancel(), this.player.debug.warn("Ads error", t);
    });
    /**
     * Setup hooks for Plyr and window events. This ensures
     * the mid- and post-roll launch at the correct time. And
     * resize the advertisement when the player resizes
     */
    f(this, "listeners", () => {
      const { container: t } = this.player.elements;
      let i;
      this.player.on("canplay", () => {
        this.addCuePoints();
      }), this.player.on("ended", () => {
        this.loader.contentComplete();
      }), this.player.on("timeupdate", () => {
        i = this.player.currentTime;
      }), this.player.on("seeked", () => {
        const n = this.player.currentTime;
        r.empty(this.cuePoints) || this.cuePoints.forEach((s, a) => {
          i < s && s < n && (this.manager.discardAdBreak(), this.cuePoints.splice(a, 1));
        });
      }), window.addEventListener("resize", () => {
        this.manager && this.manager.resize(t.offsetWidth, t.offsetHeight, google.ima.ViewMode.NORMAL);
      });
    });
    /**
     * Initialize the adsManager and start playing advertisements
     */
    f(this, "play", () => {
      const { container: t } = this.player.elements;
      this.managerPromise || this.resumeContent(), this.managerPromise.then(() => {
        this.manager.setVolume(this.player.volume), this.elements.displayContainer.initialize();
        try {
          this.initialized || (this.manager.init(t.offsetWidth, t.offsetHeight, google.ima.ViewMode.NORMAL), this.manager.start()), this.initialized = !0;
        } catch (i) {
          this.onAdError(i);
        }
      }).catch(() => {
      });
    });
    /**
     * Resume our video
     */
    f(this, "resumeContent", () => {
      this.elements.container.style.zIndex = "", this.playing = !1, W(this.player.media.play());
    });
    /**
     * Pause our video
     */
    f(this, "pauseContent", () => {
      this.elements.container.style.zIndex = 3, this.playing = !0, this.player.media.pause();
    });
    /**
     * Destroy the adsManager so we can grab new ads after this. If we don't then we're not
     * allowed to call new ads based on google policies, as they interpret this as an accidental
     * video requests. https://developers.google.com/interactive-
     * media-ads/docs/sdks/android/faq#8
     */
    f(this, "cancel", () => {
      this.initialized && this.resumeContent(), this.trigger("error"), this.loadAds();
    });
    /**
     * Re-create our adsManager
     */
    f(this, "loadAds", () => {
      this.managerPromise.then(() => {
        this.manager && this.manager.destroy(), this.managerPromise = new Promise((t) => {
          this.on("loaded", t), this.player.debug.log(this.manager);
        }), this.initialized = !1, this.requestAds();
      }).catch(() => {
      });
    });
    /**
     * Handles callbacks after an ad event was invoked
     * @param {string} event - Event type
     * @param args
     */
    f(this, "trigger", (t, ...i) => {
      const n = this.events[t];
      r.array(n) && n.forEach((s) => {
        r.function(s) && s.apply(this, i);
      });
    });
    /**
     * Add event listeners
     * @param {string} event - Event type
     * @param {Function} callback - Callback for when event occurs
     * @return {Ads}
     */
    f(this, "on", (t, i) => (r.array(this.events[t]) || (this.events[t] = []), this.events[t].push(i), this));
    /**
     * Setup a safety timer for when the ad network doesn't respond for whatever reason.
     * The advertisement has 12 seconds to get its things together. We stop this timer when the
     * advertisement is playing, or when a user action is required to start, then we clear the
     * timer on ad ready
     * @param {number} time
     * @param {string} from
     */
    f(this, "startSafetyTimer", (t, i) => {
      this.player.debug.log(`Safety timer invoked from: ${i}`), this.safetyTimer = setTimeout(() => {
        this.cancel(), this.clearSafetyTimer("startSafetyTimer()");
      }, t);
    });
    /**
     * Clear our safety timer(s)
     * @param {string} from
     */
    f(this, "clearSafetyTimer", (t) => {
      r.nullOrUndefined(this.safetyTimer) || (this.player.debug.log(`Safety timer cleared from: ${t}`), clearTimeout(this.safetyTimer), this.safetyTimer = null);
    });
    this.player = t, this.config = t.config.ads, this.playing = !1, this.initialized = !1, this.elements = {
      container: null,
      displayContainer: null
    }, this.manager = null, this.loader = null, this.cuePoints = null, this.events = {}, this.safetyTimer = null, this.countdownTimer = null, this.managerPromise = new Promise((i, n) => {
      this.on("loaded", i), this.on("error", n);
    }), this.load();
  }
  get enabled() {
    const { config: t } = this;
    return this.player.isHTML5 && this.player.isVideo && t.enabled && (!r.empty(t.publisherId) || r.url(t.tagUrl));
  }
  // Build the tag URL
  get tagUrl() {
    const { config: t } = this;
    if (r.url(t.tagUrl))
      return t.tagUrl;
    const i = {
      AV_PUBLISHERID: "58c25bb0073ef448b1087ad6",
      AV_CHANNELID: "5a0458dc28a06145e4519d21",
      AV_URL: window.location.hostname,
      cb: Date.now(),
      AV_WIDTH: 640,
      AV_HEIGHT: 480,
      AV_CDIM2: t.publisherId
    };
    return `https://go.aniview.com/api/adserver6/vast/?${pt(i)}`;
  }
}
function bt(e = 0, t = 0, i = 255) {
  return Math.min(Math.max(e, t), i);
}
function xi(e) {
  const t = [];
  return e.split(/\r\n\r\n|\n\n|\r\r/).forEach((n) => {
    const s = {};
    n.split(/\r\n|\n|\r/).forEach((o) => {
      if (r.number(s.startTime)) {
        if (!r.empty(o.trim()) && r.empty(s.text)) {
          const l = o.trim().split("#xywh=");
          [s.text] = l, l[1] && ([s.x, s.y, s.w, s.h] = l[1].split(","));
        }
      } else {
        const l = o.match(
          /(\d{2})?:?(\d{2}):(\d{2}).(\d{2,3})( ?--> ?)(\d{2})?:?(\d{2}):(\d{2}).(\d{2,3})/
        );
        l && (s.startTime = Number(l[1] || 0) * 60 * 60 + Number(l[2]) * 60 + Number(l[3]) + +`0.${l[4]}`, s.endTime = Number(l[6] || 0) * 60 * 60 + Number(l[7]) * 60 + Number(l[8]) + +`0.${l[9]}`);
      }
    }), s.text && t.push(s);
  }), t;
}
function ze(e, t) {
  const i = t.width / t.height, n = {};
  return e > i ? (n.width = t.width, n.height = 1 / e * t.width) : (n.height = t.height, n.width = e * t.height), n;
}
class xe {
  /**
   * PreviewThumbnails constructor.
   * @param {Plyr} player
   * @return {PreviewThumbnails}
   */
  constructor(t) {
    f(this, "load", () => {
      this.player.elements.display.seekTooltip && (this.player.elements.display.seekTooltip.hidden = this.enabled), this.enabled && this.getThumbnails().then(() => {
        this.enabled && (this.render(), this.determineContainerAutoSizing(), this.listeners(), this.loaded = !0);
      });
    });
    // Download VTT files and parse them
    f(this, "getThumbnails", () => new Promise((t) => {
      const { src: i } = this.player.config.previewThumbnails;
      if (r.empty(i))
        throw new Error("Missing previewThumbnails.src config attribute");
      const n = () => {
        this.thumbnails.sort((s, a) => s.height - a.height), this.player.debug.log("Preview thumbnails", this.thumbnails), t();
      };
      if (r.function(i))
        i((s) => {
          this.thumbnails = s, n();
        });
      else {
        const a = (r.string(i) ? [i] : i).map((o) => this.getThumbnail(o));
        Promise.all(a).then(n);
      }
    }));
    // Process individual VTT file
    f(this, "getThumbnail", (t) => new Promise((i) => {
      le(t, void 0, this.player.config.previewThumbnails.withCredentials).then((n) => {
        const s = {
          frames: xi(n),
          height: null,
          urlPrefix: ""
        };
        !s.frames[0].text.startsWith("/") && !s.frames[0].text.startsWith("http://") && !s.frames[0].text.startsWith("https://") && (s.urlPrefix = t.substring(0, t.lastIndexOf("/") + 1));
        const a = new Image();
        a.onload = () => {
          s.height = a.naturalHeight, s.width = a.naturalWidth, this.thumbnails.push(s), i();
        }, a.src = s.urlPrefix + s.frames[0].text;
      });
    }));
    f(this, "startMove", (t) => {
      var i, n;
      if (this.loaded && !(!r.event(t) || !["touchmove", "mousemove"].includes(t.type)) && this.player.media.duration) {
        if (t.type === "touchmove")
          this.seekTime = this.player.media.duration * (this.player.elements.inputs.seek.value / 100);
        else {
          const s = this.player.elements.progress.getBoundingClientRect(), a = 100 / s.width * (t.pageX - s.left);
          this.seekTime = this.player.media.duration * (a / 100), this.seekTime < 0 && (this.seekTime = 0), this.seekTime > this.player.media.duration - 1 && (this.seekTime = this.player.media.duration - 1), this.mousePosX = t.pageX, this.elements.thumb.time.textContent = we(this.seekTime);
          const o = (n = (i = this.player.config.markers) == null ? void 0 : i.points) == null ? void 0 : n.find(({ time: l }) => l === Math.round(this.seekTime));
          o && this.elements.thumb.time.insertAdjacentHTML("afterbegin", `${o.label}<br>`);
        }
        this.showImageAtCurrentTime();
      }
    });
    f(this, "endMove", () => {
      this.toggleThumbContainer(!1, !0);
    });
    f(this, "startScrubbing", (t) => {
      (r.nullOrUndefined(t.button) || t.button === !1 || t.button === 0) && (this.mouseDown = !0, this.player.media.duration && (this.toggleScrubbingContainer(!0), this.toggleThumbContainer(!1, !0), this.showImageAtCurrentTime()));
    });
    f(this, "endScrubbing", () => {
      this.mouseDown = !1, Math.ceil(this.lastTime) === Math.ceil(this.player.media.currentTime) ? this.toggleScrubbingContainer(!1) : Ie.call(this.player, this.player.media, "timeupdate", () => {
        this.mouseDown || this.toggleScrubbingContainer(!1);
      });
    });
    /**
     * Setup hooks for Plyr and window events
     */
    f(this, "listeners", () => {
      this.player.on("play", () => {
        this.toggleThumbContainer(!1, !0);
      }), this.player.on("seeked", () => {
        this.toggleThumbContainer(!1);
      }), this.player.on("timeupdate", () => {
        this.lastTime = this.player.media.currentTime;
      });
    });
    /**
     * Create HTML elements for image containers
     */
    f(this, "render", () => {
      this.elements.thumb.container = v("div", {
        class: this.player.config.classNames.previewThumbnails.thumbContainer
      }), this.elements.thumb.imageContainer = v("div", {
        class: this.player.config.classNames.previewThumbnails.imageContainer
      }), this.elements.thumb.container.appendChild(this.elements.thumb.imageContainer);
      const t = v("div", {
        class: this.player.config.classNames.previewThumbnails.timeContainer
      });
      this.elements.thumb.time = v("span", {}, "00:00"), t.appendChild(this.elements.thumb.time), this.elements.thumb.imageContainer.appendChild(t), r.element(this.player.elements.progress) && this.player.elements.progress.appendChild(this.elements.thumb.container), this.elements.scrubbing.container = v("div", {
        class: this.player.config.classNames.previewThumbnails.scrubbingContainer
      }), this.player.elements.wrapper.appendChild(this.elements.scrubbing.container);
    });
    f(this, "destroy", () => {
      this.elements.thumb.container && this.elements.thumb.container.remove(), this.elements.scrubbing.container && this.elements.scrubbing.container.remove();
    });
    f(this, "showImageAtCurrentTime", () => {
      this.mouseDown ? this.setScrubbingContainerSize() : this.setThumbContainerSizeAndPos();
      const t = this.thumbnails[0].frames.findIndex(
        (s) => this.seekTime >= s.startTime && this.seekTime <= s.endTime
      ), i = t >= 0;
      let n = 0;
      this.mouseDown || this.toggleThumbContainer(i), i && (this.thumbnails.forEach((s, a) => {
        this.loadedImages.includes(s.frames[t].text) && (n = a);
      }), t !== this.showingThumb && (this.showingThumb = t, this.loadImage(n)));
    });
    // Show the image that's currently specified in this.showingThumb
    f(this, "loadImage", (t = 0) => {
      const i = this.showingThumb, n = this.thumbnails[t], { urlPrefix: s } = n, a = n.frames[i], o = n.frames[i].text, l = s + o;
      if (!this.currentImageElement || this.currentImageElement.dataset.filename !== o) {
        this.loadingImage && this.usingSprites && (this.loadingImage.onload = null);
        const c = new Image();
        c.src = l, c.dataset.index = i, c.dataset.filename = o, this.showingThumbFilename = o, this.player.debug.log(`Loading image: ${l}`), c.onload = () => this.showImage(c, a, t, i, o, !0), this.loadingImage = c, this.removeOldImages(c);
      } else
        this.showImage(this.currentImageElement, a, t, i, o, !1), this.currentImageElement.dataset.index = i, this.removeOldImages(this.currentImageElement);
    });
    f(this, "showImage", (t, i, n, s, a, o = !0) => {
      this.player.debug.log(
        `Showing thumb: ${a}. num: ${s}. qual: ${n}. newimg: ${o}`
      ), this.setImageSizeAndOffset(t, i), o && (this.currentImageContainer.appendChild(t), this.currentImageElement = t, this.loadedImages.includes(a) || this.loadedImages.push(a)), this.preloadNearby(s, !0).then(this.preloadNearby(s, !1)).then(this.getHigherQuality(n, t, i, a));
    });
    // Remove all preview images that aren't the designated current image
    f(this, "removeOldImages", (t) => {
      Array.from(this.currentImageContainer.children).forEach((i) => {
        if (i.tagName.toLowerCase() !== "img")
          return;
        const n = this.usingSprites ? 500 : 1e3;
        if (i.dataset.index !== t.dataset.index && !i.dataset.deleting) {
          i.dataset.deleting = !0;
          const { currentImageContainer: s } = this;
          setTimeout(() => {
            s.removeChild(i), this.player.debug.log(`Removing thumb: ${i.dataset.filename}`);
          }, n);
        }
      });
    });
    // Preload images before and after the current one. Only if the user is still hovering/seeking the same frame
    // This will only preload the lowest quality
    f(this, "preloadNearby", (t, i = !0) => new Promise((n) => {
      setTimeout(() => {
        const s = this.thumbnails[0].frames[t].text;
        if (this.showingThumbFilename === s) {
          let a;
          i ? a = this.thumbnails[0].frames.slice(t) : a = this.thumbnails[0].frames.slice(0, t).reverse();
          let o = !1;
          a.forEach((l) => {
            const c = l.text;
            if (c !== s && !this.loadedImages.includes(c)) {
              o = !0, this.player.debug.log(`Preloading thumb filename: ${c}`);
              const { urlPrefix: u } = this.thumbnails[0], m = u + c, b = new Image();
              b.src = m, b.onload = () => {
                this.player.debug.log(`Preloaded thumb filename: ${c}`), this.loadedImages.includes(c) || this.loadedImages.push(c), n();
              };
            }
          }), o || n();
        }
      }, 300);
    }));
    // If user has been hovering current image for half a second, look for a higher quality one
    f(this, "getHigherQuality", (t, i, n, s) => {
      if (t < this.thumbnails.length - 1) {
        let a = i.naturalHeight;
        this.usingSprites && (a = n.h), a < this.thumbContainerHeight && setTimeout(() => {
          this.showingThumbFilename === s && (this.player.debug.log(`Showing higher quality thumb for: ${s}`), this.loadImage(t + 1));
        }, 300);
      }
    });
    f(this, "toggleThumbContainer", (t = !1, i = !1) => {
      const n = this.player.config.classNames.previewThumbnails.thumbContainerShown;
      this.elements.thumb.container.classList.toggle(n, t), !t && i && (this.showingThumb = null, this.showingThumbFilename = null);
    });
    f(this, "toggleScrubbingContainer", (t = !1) => {
      const i = this.player.config.classNames.previewThumbnails.scrubbingContainerShown;
      this.elements.scrubbing.container.classList.toggle(i, t), t || (this.showingThumb = null, this.showingThumbFilename = null);
    });
    f(this, "determineContainerAutoSizing", () => {
      (this.elements.thumb.imageContainer.clientHeight > 20 || this.elements.thumb.imageContainer.clientWidth > 20) && (this.sizeSpecifiedInCSS = !0);
    });
    // Set the size to be about a quarter of the size of video. Unless option dynamicSize === false, in which case it needs to be set in CSS
    f(this, "setThumbContainerSizeAndPos", () => {
      const { imageContainer: t } = this.elements.thumb;
      if (this.sizeSpecifiedInCSS) {
        if (t.clientHeight > 20 && t.clientWidth < 20) {
          const i = Math.floor(t.clientHeight * this.thumbAspectRatio);
          t.style.width = `${i}px`;
        } else if (t.clientHeight < 20 && t.clientWidth > 20) {
          const i = Math.floor(t.clientWidth / this.thumbAspectRatio);
          t.style.height = `${i}px`;
        }
      } else {
        const i = Math.floor(this.thumbContainerHeight * this.thumbAspectRatio);
        t.style.height = `${this.thumbContainerHeight}px`, t.style.width = `${i}px`;
      }
      this.setThumbContainerPos();
    });
    f(this, "setThumbContainerPos", () => {
      const t = this.player.elements.progress.getBoundingClientRect(), i = this.player.elements.container.getBoundingClientRect(), { container: n } = this.elements.thumb, s = i.left - t.left + 10, a = i.right - t.left - n.clientWidth - 10, o = this.mousePosX - t.left - n.clientWidth / 2, l = bt(o, s, a);
      n.style.left = `${l}px`, n.style.setProperty("--preview-arrow-offset", `${o - l}px`);
    });
    // Can't use 100% width, in case the video is a different aspect ratio to the video container
    f(this, "setScrubbingContainerSize", () => {
      const { width: t, height: i } = ze(this.thumbAspectRatio, {
        width: this.player.media.clientWidth,
        height: this.player.media.clientHeight
      });
      this.elements.scrubbing.container.style.width = `${t}px`, this.elements.scrubbing.container.style.height = `${i}px`;
    });
    // Sprites need to be offset to the correct location
    f(this, "setImageSizeAndOffset", (t, i) => {
      if (!this.usingSprites) return;
      const n = this.thumbContainerHeight / i.h;
      t.style.height = `${t.naturalHeight * n}px`, t.style.width = `${t.naturalWidth * n}px`, t.style.left = `-${i.x * n}px`, t.style.top = `-${i.y * n}px`;
    });
    this.player = t, this.thumbnails = [], this.loaded = !1, this.lastMouseMoveTime = Date.now(), this.mouseDown = !1, this.loadedImages = [], this.elements = {
      thumb: {},
      scrubbing: {}
    }, this.load();
  }
  get enabled() {
    return this.player.isHTML5 && this.player.isVideo && this.player.config.previewThumbnails.enabled;
  }
  get currentImageContainer() {
    return this.mouseDown ? this.elements.scrubbing.container : this.elements.thumb.imageContainer;
  }
  get usingSprites() {
    return Object.keys(this.thumbnails[0].frames[0]).includes("w");
  }
  get thumbAspectRatio() {
    return this.usingSprites ? this.thumbnails[0].frames[0].w / this.thumbnails[0].frames[0].h : this.thumbnails[0].width / this.thumbnails[0].height;
  }
  get thumbContainerHeight() {
    if (this.mouseDown) {
      const { height: t } = ze(this.thumbAspectRatio, {
        width: this.player.media.clientWidth,
        height: this.player.media.clientHeight
      });
      return t;
    }
    return this.sizeSpecifiedInCSS ? this.elements.thumb.imageContainer.clientHeight : Math.floor(this.player.media.clientWidth / this.thumbAspectRatio / 4);
  }
  get currentImageElement() {
    return this.mouseDown ? this.currentScrubbingImageElement : this.currentThumbnailImageElement;
  }
  set currentImageElement(t) {
    this.mouseDown ? this.currentScrubbingImageElement = t : this.currentThumbnailImageElement = t;
  }
}
const Le = {
  // Add elements to HTML5 media (source, tracks, etc)
  insertElements(e, t) {
    r.string(t) ? Fe(e, this.media, {
      src: t
    }) : r.array(t) && t.forEach((i) => {
      Fe(e, this.media, i);
    });
  },
  // Update source
  // Sources are not checked for support so be careful
  change(e) {
    if (!nt(e, "sources.length")) {
      this.debug.warn("Invalid source format");
      return;
    }
    X.cancelRequests.call(this), this.destroy(() => {
      this.options.quality = [], B(this.media), this.media = null, r.element(this.elements.container) && this.elements.container.removeAttribute("class");
      const { sources: t, type: i } = e, [{ provider: n = Y.html5, src: s }] = t, a = n === "html5" ? i : "div", o = n === "html5" ? {} : { src: s };
      Object.assign(this, {
        provider: n,
        type: i,
        // Check for support
        supported: O.check(i, n, this.config.playsinline),
        // Create new element
        media: v(a, o)
      }), this.elements.container.appendChild(this.media), r.boolean(e.autoplay) && (this.config.autoplay = e.autoplay), this.isHTML5 && (this.config.crossorigin && this.media.setAttribute("crossorigin", ""), this.config.autoplay && this.media.setAttribute("autoplay", ""), r.empty(e.poster) || (this.poster = e.poster), this.config.loop.active && this.media.setAttribute("loop", ""), this.config.muted && this.media.setAttribute("muted", ""), this.config.playsinline && this.media.setAttribute("playsinline", "")), L.addStyleHook.call(this), this.isHTML5 && Le.insertElements.call(this, "source", t), this.config.title = e.title, yt.setup.call(this), this.isHTML5 && Object.keys(e).includes("tracks") && Le.insertElements.call(this, "track", e.tracks), (this.isHTML5 || this.isEmbed && !this.supported.ui) && L.build.call(this), this.isHTML5 && this.media.load(), r.empty(e.previewThumbnails) || (Object.assign(this.config.previewThumbnails, e.previewThumbnails), this.previewThumbnails && this.previewThumbnails.loaded && (this.previewThumbnails.destroy(), this.previewThumbnails = null), this.config.previewThumbnails.enabled && (this.previewThumbnails = new xe(this))), this.fullscreen.update();
    }, !0);
  }
};
class re {
  constructor(t, i) {
    /**
     * Play the media, or play the advertisement (if they are not blocked)
     */
    f(this, "play", () => r.function(this.media.play) ? (this.ads && this.ads.enabled && this.ads.managerPromise.then(() => this.ads.play()).catch(() => W(this.media.play())), this.media.play()) : null);
    /**
     * Pause the media
     */
    f(this, "pause", () => !this.playing || !r.function(this.media.pause) ? null : this.media.pause());
    /**
     * Toggle playback based on current status
     * @param {boolean} input
     */
    f(this, "togglePlay", (t) => (r.boolean(t) ? t : !this.playing) ? this.play() : this.pause());
    /**
     * Stop playback
     */
    f(this, "stop", () => {
      this.isHTML5 ? (this.pause(), this.restart()) : r.function(this.media.stop) && this.media.stop();
    });
    /**
     * Restart playback
     */
    f(this, "restart", () => {
      this.currentTime = 0;
    });
    /**
     * Rewind
     * @param {number} seekTime - how far to rewind in seconds. Defaults to the config.seekTime
     */
    f(this, "rewind", (t) => {
      this.currentTime -= r.number(t) ? t : this.config.seekTime;
    });
    /**
     * Fast forward
     * @param {number} seekTime - how far to fast forward in seconds. Defaults to the config.seekTime
     */
    f(this, "forward", (t) => {
      this.currentTime += r.number(t) ? t : this.config.seekTime;
    });
    /**
     * Increase volume
     * @param {boolean} step - How much to decrease by (between 0 and 1)
     */
    f(this, "increaseVolume", (t) => {
      const i = this.media.muted ? 0 : this.volume;
      this.volume = i + (r.number(t) ? t : 0);
    });
    /**
     * Decrease volume
     * @param {boolean} step - How much to decrease by (between 0 and 1)
     */
    f(this, "decreaseVolume", (t) => {
      this.increaseVolume(-t);
    });
    /**
     * Trigger the airplay dialog
     * TODO: update player with state, support, enabled
     */
    f(this, "airplay", () => {
      O.airplay && this.media.webkitShowPlaybackTargetPicker();
    });
    /**
     * Toggle the player controls
     * @param {boolean} [toggle] - Whether to show the controls
     */
    f(this, "toggleControls", (t) => {
      if (this.supported.ui && !this.isAudio) {
        const i = pe(this.elements.container, this.config.classNames.hideControls), n = typeof t > "u" ? void 0 : !t, s = P(this.elements.container, this.config.classNames.hideControls, n);
        if (s && r.array(this.config.controls) && this.config.controls.includes("settings") && !r.empty(this.config.settings) && p.toggleMenu.call(this, !1), s !== i) {
          const a = s ? "controlshidden" : "controlsshown";
          k.call(this, this.media, a);
        }
        return !s;
      }
      return !1;
    });
    /**
     * Add event listeners
     * @param {string} event - Event type
     * @param {Function} callback - Callback for when event occurs
     */
    f(this, "on", (t, i) => {
      E.call(this, this.elements.container, t, i);
    });
    /**
     * Add event listeners once
     * @param {string} event - Event type
     * @param {Function} callback - Callback for when event occurs
     */
    f(this, "once", (t, i) => {
      Ie.call(this, this.elements.container, t, i);
    });
    /**
     * Remove event listeners
     * @param {string} event - Event type
     * @param {Function} callback - Callback for when event occurs
     */
    f(this, "off", (t, i) => {
      be(this.elements.container, t, i);
    });
    /**
     * Destroy an instance
     * Event listeners are removed when elements are removed
     * http://stackoverflow.com/questions/12528049/if-a-dom-element-is-removed-are-its-listeners-also-removed-from-memory
     * @param {Function} callback - Callback for when destroy is complete
     * @param {boolean} soft - Whether it's a soft destroy (for source changes etc)
     */
    f(this, "destroy", (t, i = !1) => {
      if (!this.ready)
        return;
      const n = () => {
        document.body.style.overflow = "", this.embed = null, i ? (Object.keys(this.elements).length && (B(this.elements.buttons.play), B(this.elements.captions), B(this.elements.controls), B(this.elements.wrapper), this.elements.buttons.play = null, this.elements.captions = null, this.elements.controls = null, this.elements.wrapper = null), r.function(t) && t()) : (ei.call(this), X.cancelRequests.call(this), me(this.elements.original, this.elements.container), k.call(this, this.elements.original, "destroyed", !0), r.function(t) && t.call(this.elements.original), this.ready = !1, setTimeout(() => {
          this.elements = null, this.media = null;
        }, 200));
      };
      this.stop(), clearTimeout(this.timers.loading), clearTimeout(this.timers.controls), clearTimeout(this.timers.resized), this.isHTML5 ? (L.toggleNativeControls.call(this, !0), n()) : this.isYouTube ? (clearInterval(this.timers.buffering), clearInterval(this.timers.playing), this.embed !== null && r.function(this.embed.destroy) && this.embed.destroy(), n()) : this.isVimeo && (this.embed !== null && this.embed.unload().then(n), setTimeout(n, 200));
    });
    /**
     * Check for support for a mime type (HTML5 only)
     * @param {string} type - Mime type
     */
    f(this, "supports", (t) => O.mime.call(this, t));
    if (this.timers = {}, this.ready = !1, this.loading = !1, this.failed = !1, this.touch = O.touch, this.media = t, r.string(this.media) && (this.media = document.querySelectorAll(this.media)), (window.jQuery && this.media instanceof jQuery || r.nodeList(this.media) || r.array(this.media)) && (this.media = this.media[0]), this.config = I(
      {},
      ft,
      re.defaults,
      i || {},
      (() => {
        try {
          return JSON.parse(this.media.getAttribute("data-plyr-config"));
        } catch {
          return {};
        }
      })()
    ), this.elements = {
      container: null,
      fullscreen: null,
      captions: null,
      buttons: {},
      display: {},
      progress: {},
      inputs: {},
      settings: {
        popup: null,
        menu: null,
        panels: {},
        buttons: {}
      }
    }, this.captions = {
      active: null,
      currentTrack: -1,
      meta: /* @__PURE__ */ new WeakMap()
    }, this.fullscreen = {
      active: !1
    }, this.options = {
      speed: [],
      quality: []
    }, this.debug = new yi(this.config.debug), this.debug.log("Config", this.config), this.debug.log("Support", O), r.nullOrUndefined(this.media) || !r.element(this.media)) {
      this.debug.error("Setup failed: no suitable element passed");
      return;
    }
    if (this.media.plyr) {
      this.debug.warn("Target already setup");
      return;
    }
    if (!this.config.enabled) {
      this.debug.error("Setup failed: disabled by config");
      return;
    }
    if (!O.check().api) {
      this.debug.error("Setup failed: no support");
      return;
    }
    const n = this.media.cloneNode(!0);
    n.autoplay = !1, this.elements.original = n;
    const s = this.media.tagName.toLowerCase();
    let a = null, o = null;
    switch (s) {
      case "div":
        if (a = this.media.querySelector("iframe"), r.element(a)) {
          if (o = mt(a.getAttribute("src")), this.provider = gi(o.toString()), this.elements.container = this.media, this.media = a, this.elements.container.className = "", o.search.length) {
            const l = ["1", "true"];
            l.includes(o.searchParams.get("autoplay")) && (this.config.autoplay = !0), l.includes(o.searchParams.get("loop")) && (this.config.loop.active = !0), this.isYouTube ? (this.config.playsinline = l.includes(o.searchParams.get("playsinline")), this.config.youtube.hl = o.searchParams.get("hl")) : this.config.playsinline = !0;
          }
        } else
          this.provider = this.media.getAttribute(this.config.attributes.embed.provider), this.media.removeAttribute(this.config.attributes.embed.provider);
        if (r.empty(this.provider) || !Object.values(Y).includes(this.provider)) {
          this.debug.error("Setup failed: Invalid provider");
          return;
        }
        this.type = Te.video;
        break;
      case "video":
      case "audio":
        this.type = s, this.provider = Y.html5, this.media.hasAttribute("crossorigin") && (this.config.crossorigin = !0), this.media.hasAttribute("autoplay") && (this.config.autoplay = !0), (this.media.hasAttribute("playsinline") || this.media.hasAttribute("webkit-playsinline")) && (this.config.playsinline = !0), this.media.hasAttribute("muted") && (this.config.muted = !0), this.media.hasAttribute("loop") && (this.config.loop.active = !0);
        break;
      default:
        this.debug.error("Setup failed: unsupported type");
        return;
    }
    if (this.supported = O.check(this.type, this.provider), !this.supported.api) {
      this.debug.error("Setup failed: no support");
      return;
    }
    this.eventListeners = [], this.listeners = new bi(this), this.storage = new ne(this), this.media.plyr = this, r.element(this.elements.container) || (this.elements.container = v("div"), rt(this.media, this.elements.container)), L.migrateStyles.call(this), L.addStyleHook.call(this), yt.setup.call(this), this.config.debug && E.call(this, this.elements.container, this.config.events.join(" "), (l) => {
      this.debug.log(`event: ${l.type}`);
    }), this.fullscreen = new U(this), (this.isHTML5 || this.isEmbed && !this.supported.ui) && L.build.call(this), this.listeners.container(), this.listeners.global(), this.config.ads.enabled && (this.ads = new Mi(this)), this.isHTML5 && this.config.autoplay && this.once("canplay", () => W(this.play())), this.lastSeekTime = 0, this.config.previewThumbnails.enabled && (this.previewThumbnails = new xe(this));
  }
  // ---------------------------------------
  // API
  // ---------------------------------------
  /**
   * Types and provider helpers
   */
  get isHTML5() {
    return this.provider === Y.html5;
  }
  get isEmbed() {
    return this.isYouTube || this.isVimeo;
  }
  get isYouTube() {
    return this.provider === Y.youtube;
  }
  get isVimeo() {
    return this.provider === Y.vimeo;
  }
  get isVideo() {
    return this.type === Te.video;
  }
  get isAudio() {
    return this.type === Te.audio;
  }
  /**
   * Get playing state
   */
  get playing() {
    return !!(this.ready && !this.paused && !this.ended);
  }
  /**
   * Get paused state
   */
  get paused() {
    return !!this.media.paused;
  }
  /**
   * Get stopped state
   */
  get stopped() {
    return !!(this.paused && this.currentTime === 0);
  }
  /**
   * Get ended state
   */
  get ended() {
    return !!this.media.ended;
  }
  /**
   * Seek to a time
   * @param {number} input - where to seek to in seconds. Defaults to 0 (the start)
   */
  set currentTime(t) {
    if (!this.duration)
      return;
    const i = r.number(t) && t > 0;
    this.media.currentTime = i ? Math.min(t, this.duration) : 0, this.debug.log(`Seeking to ${this.currentTime} seconds`);
  }
  /**
   * Get current time
   */
  get currentTime() {
    return Number(this.media.currentTime);
  }
  /**
   * Get buffered
   */
  get buffered() {
    const { buffered: t } = this.media;
    return r.number(t) ? t : t && t.length && this.duration > 0 ? t.end(0) / this.duration : 0;
  }
  /**
   * Get seeking status
   */
  get seeking() {
    return !!this.media.seeking;
  }
  /**
   * Get the duration of the current media
   */
  get duration() {
    const t = Number.parseFloat(this.config.duration), i = (this.media || {}).duration, n = !r.number(i) || i === 1 / 0 ? 0 : i;
    return t || n;
  }
  /**
   * Set the player volume
   * @param {number} value - must be between 0 and 1. Defaults to the value from local storage and config.volume if not set in storage
   */
  set volume(t) {
    let i = t;
    const n = 1, s = 0;
    r.string(i) && (i = Number(i)), r.number(i) || (i = this.storage.get("volume")), r.number(i) || ({ volume: i } = this.config), i > n && (i = n), i < s && (i = s), this.config.volume = i, this.media.volume = i, !r.empty(t) && this.muted && i > 0 && (this.muted = !1);
  }
  /**
   * Get the current player volume
   */
  get volume() {
    return Number(this.media.volume);
  }
  /**
   * Set muted state
   * @param {boolean} mute
   */
  set muted(t) {
    let i = t;
    r.boolean(i) || (i = this.storage.get("muted")), r.boolean(i) || (i = this.config.muted), this.config.muted = i, this.media.muted = i;
  }
  /**
   * Get current muted state
   */
  get muted() {
    return !!this.media.muted;
  }
  /**
   * Check if the media has audio
   */
  get hasAudio() {
    return !this.isHTML5 || this.isAudio ? !0 : !!this.media.mozHasAudio || !!this.media.webkitAudioDecodedByteCount || !!(this.media.audioTracks && this.media.audioTracks.length);
  }
  /**
   * Set playback speed
   * @param {number} input - the speed of playback (0.5-2.0)
   */
  set speed(t) {
    let i = null;
    r.number(t) && (i = t), r.number(i) || (i = this.storage.get("speed")), r.number(i) || (i = this.config.speed.selected);
    const { minimumSpeed: n, maximumSpeed: s } = this;
    i = bt(i, n, s), this.config.speed.selected = i, setTimeout(() => {
      this.media && (this.media.playbackRate = i);
    }, 0);
  }
  /**
   * Get current playback speed
   */
  get speed() {
    return Number(this.media.playbackRate);
  }
  /**
   * Get the minimum allowed speed
   */
  get minimumSpeed() {
    return this.isYouTube ? Math.min(...this.options.speed) : this.isVimeo ? 0.5 : 0.0625;
  }
  /**
   * Get the maximum allowed speed
   */
  get maximumSpeed() {
    return this.isYouTube ? Math.max(...this.options.speed) : this.isVimeo ? 2 : 16;
  }
  /**
   * Set playback quality
   * Currently HTML5 & YouTube only
   * @param {number} input - Quality level
   */
  set quality(t) {
    const i = this.config.quality, n = this.options.quality;
    if (!n.length)
      return;
    let s = [
      !r.empty(t) && Number(t),
      this.storage.get("quality"),
      i.selected,
      i.default
    ].find(r.number), a = !0;
    if (!n.includes(s)) {
      const o = at(n, s);
      this.debug.warn(`Unsupported quality option: ${s}, using ${o} instead`), s = o, a = !1;
    }
    i.selected = s, this.media.quality = s, a && this.storage.set({ quality: s });
  }
  /**
   * Get current quality level
   */
  get quality() {
    return this.media.quality;
  }
  /**
   * Toggle loop
   * TODO: Finish fancy new logic. Set the indicator on load as user may pass loop as config
   * @param {boolean} input - Whether to loop or not
   */
  set loop(t) {
    const i = r.boolean(t) ? t : this.config.loop.active;
    this.config.loop.active = i, this.media.loop = i;
  }
  /**
   * Get current loop state
   */
  get loop() {
    return !!this.media.loop;
  }
  /**
   * Set new media source
   * @param {object} input - The new source object (see docs)
   */
  set source(t) {
    Le.change.call(this, t);
  }
  /**
   * Get current source
   */
  get source() {
    return this.media.currentSrc;
  }
  /**
   * Get a download URL (either source or custom)
   */
  get download() {
    const { download: t } = this.config.urls;
    return r.url(t) ? t : this.source;
  }
  /**
   * Set the download URL
   */
  set download(t) {
    r.url(t) && (this.config.urls.download = t, p.setDownloadUrl.call(this));
  }
  /**
   * Set the poster image for a video
   * @param {string} input - the URL for the new poster image
   */
  set poster(t) {
    if (!this.isVideo) {
      this.debug.warn("Poster can only be set for video");
      return;
    }
    L.setPoster.call(this, t, !1).catch(() => {
    });
  }
  /**
   * Get the current poster image
   */
  get poster() {
    return this.isVideo ? this.media.getAttribute("poster") || this.media.getAttribute("data-poster") : null;
  }
  /**
   * Get the current aspect ratio in use
   */
  get ratio() {
    if (!this.isVideo)
      return null;
    const t = fe(Oe.call(this));
    return r.array(t) ? t.join(":") : t;
  }
  /**
   * Set video aspect ratio
   */
  set ratio(t) {
    if (!this.isVideo) {
      this.debug.warn("Aspect ratio can only be set for video");
      return;
    }
    if (!r.string(t) || !lt(t)) {
      this.debug.error(`Invalid aspect ratio specified (${t})`);
      return;
    }
    this.config.ratio = fe(t), J.call(this);
  }
  /**
   * Set the autoplay state
   * @param {boolean} input - Whether to autoplay or not
   */
  set autoplay(t) {
    this.config.autoplay = r.boolean(t) ? t : this.config.autoplay;
  }
  /**
   * Get the current autoplay state
   */
  get autoplay() {
    return !!this.config.autoplay;
  }
  /**
   * Toggle captions
   * @param {boolean} input - Whether to enable captions
   */
  toggleCaptions(t) {
    S.toggle.call(this, t, !1);
  }
  /**
   * Set the caption track by index
   * @param {number} input - Caption index
   */
  set currentTrack(t) {
    S.set.call(this, t, !1), S.setup.call(this);
  }
  /**
   * Get the current caption track index (-1 if disabled)
   */
  get currentTrack() {
    const { toggled: t, currentTrack: i } = this.captions;
    return t ? i : -1;
  }
  /**
   * Set the wanted language for captions
   * Since tracks can be added later it won't update the actual caption track until there is a matching track
   * @param {string} input - Two character ISO language code (e.g. EN, FR, PT, etc)
   */
  set language(t) {
    S.setLanguage.call(this, t, !1);
  }
  /**
   * Get the current track's language
   */
  get language() {
    return (S.getCurrentTrack.call(this) || {}).language;
  }
  /**
   * Toggle picture-in-picture playback on WebKit/MacOS
   * TODO: update player with state, support, enabled
   * TODO: detect outside changes
   */
  set pip(t) {
    if (!O.pip)
      return;
    const i = r.boolean(t) ? t : !this.pip;
    r.function(this.media.webkitSetPresentationMode) && this.media.webkitSetPresentationMode(i ? ke.active : ke.inactive), r.function(this.media.requestPictureInPicture) && (!this.pip && i ? this.media.requestPictureInPicture() : this.pip && !i && document.exitPictureInPicture());
  }
  /**
   * Get the current picture-in-picture state
   */
  get pip() {
    return O.pip ? r.empty(this.media.webkitPresentationMode) ? this.media === document.pictureInPictureElement : this.media.webkitPresentationMode === ke.active : null;
  }
  /**
   * Sets the preview thumbnails for the current source
   */
  setPreviewThumbnails(t) {
    this.previewThumbnails && this.previewThumbnails.loaded && (this.previewThumbnails.destroy(), this.previewThumbnails = null), Object.assign(this.config.previewThumbnails, t), this.config.previewThumbnails.enabled && (this.previewThumbnails = new xe(this));
  }
  /**
   * Check for support
   * @param {string} type - Player type (audio/video)
   * @param {string} provider - Provider (html5/youtube/vimeo)
   */
  static supported(t, i) {
    return O.check(t, i);
  }
  /**
   * Load an SVG sprite into the page
   * @param {string} url - URL for the SVG sprite
   * @param {string} [id] - Unique ID
   */
  static loadSprite(t, i) {
    return dt(t, i);
  }
  /**
   * Setup multiple instances
   * @param {*} selector
   * @param {object} options
   */
  static setup(t, i = {}) {
    let n = null;
    return r.string(t) ? n = Array.from(document.querySelectorAll(t)) : r.nodeList(t) ? n = Array.from(t) : r.array(t) && (n = t.filter(r.element)), r.empty(n) ? null : n.map((s) => new re(s, i));
  }
}
re.defaults = Qt(ft);
let z = null, F = null, V = null;
function ge(e) {
  if (!e || !(e instanceof HTMLElement))
    throw new Error("Element is not an HTMLElement");
}
function De() {
  if (V) {
    try {
      const e = V.src;
      V.pause(), V.src = "", V.load(), e.startsWith("blob:") && URL.revokeObjectURL(e);
    } catch (e) {
      console.warn("Error cleaning up video element:", e);
    }
    V = null;
  }
}
function wt() {
  return `
        <div class="w-100 h-100 d-flex flex-column align-items-center justify-content-center" style="height: 400px;">
            <div class="loading-status text-white mb-3">Initializing...</div>
            <div class="progress w-75">
                <div class="progress-bar bg-primary" role="progressbar" style="width: 0%; height: 20px;"></div>
            </div>
        </div>
    `;
}
function vt() {
  const e = document.createElement("video");
  return e.style.display = "none", e.className = "w-100 h-100", e.style.objectFit = "contain", e.playsInline = !0, e.controls = !0, e.preload = "auto", e.style.maxHeight = "100%", e.style.maxWidth = "100%", e;
}
async function kt(e) {
  try {
    if (console.log("Initializing WebTorrent for element:", e), !window.WebTorrent)
      throw new Error("WebTorrent library not loaded");
    z || (z = new window.WebTorrent(), console.log("WebTorrent client created"));
  } catch (t) {
    throw console.error("Error initializing WebTorrent:", t), t;
  }
}
async function $i(e, t, i, n) {
  return console.log("Starting download for element:", e), De(), z || (console.log("Client not initialized, setting up..."), await kt(e)), F && (console.log("Destroying existing torrent..."), F.destroy(), F = null), new Promise((s, a) => {
    try {
      const o = document.querySelector(t);
      if (!o)
        throw new Error(`Container element not found: ${t}`);
      o.innerHTML = wt();
      const l = o.querySelector(".loading-status"), c = o.querySelector(".progress-bar");
      l && ge(l), c && ge(c);
      const u = {
        announce: [
          "wss://tracker.openwebtorrent.com",
          "wss://tracker.webtorrent.dev",
          "wss://tracker.btorrent.xyz"
        ],
        maxWebConns: 8,
        strategy: "sequential"
      };
      z.add(i, u, (m) => {
        console.log("Torrent added, files:", m.files.length), F = m;
        const b = m.files.find((h) => {
          const y = h.name.toLowerCase(), w = y.endsWith(".mp4") || y.endsWith(".webm") || y.endsWith(".mkv") || y.endsWith(".avi") || y.endsWith(".mov") || y.endsWith(".wmv") || y.endsWith(".flv");
          return console.log("Checking file:", h.name, "isVideo:", w), w;
        });
        if (!b) {
          const h = "No video file found in torrent";
          console.error(h), n && n.invokeMethodAsync("OnTorrentErrorCallback", h), a(new Error(h));
          return;
        }
        console.log("Video file found:", b.name), n && n.invokeMethodAsync("OnTorrentReadyCallback");
        const d = vt();
        V = d, o.appendChild(d), b.getBlobURL((h, y) => {
          if (h) {
            console.error("Error getting blob URL:", h), n && n.invokeMethodAsync("OnTorrentErrorCallback", h.toString()), a(h);
            return;
          }
          if (!y) {
            const T = "No blob URL received";
            console.error(T), n && n.invokeMethodAsync("OnTorrentErrorCallback", T), a(new Error(T));
            return;
          }
          console.log("Got blob URL, setting up video..."), d.src = y, d.style.display = "block";
          const w = o.querySelector(".d-flex");
          w && w.remove(), d.addEventListener("loadedmetadata", () => {
            console.log("Video metadata loaded"), m.progress > 0.05 && d.play().catch((T) => {
              console.warn("Could not auto-start video:", T);
            });
          }), d.addEventListener("error", (T) => {
            console.error("Video error:", T), n && n.invokeMethodAsync("OnTorrentErrorCallback", "Video playback error");
          });
        }), m.on("download", () => {
          const h = Math.round(m.progress * 100);
          l && (l.textContent = `Loading: ${h}%`), c && (c.style.width = `${h}%`), n && n.invokeMethodAsync("OnTorrentProgressUpdate", h), m.progress > 0.05 && V && V.paused && V.play().catch((y) => {
            console.warn("Could not start video:", y);
          });
        }), m.on("done", () => {
          console.log("Download complete"), n && n.invokeMethodAsync("OnTorrentProgressUpdate", 100), s();
        }), m.on("error", (h) => {
          console.error("Torrent error:", h), n && n.invokeMethodAsync("OnTorrentErrorCallback", h.message), a(h);
        }), m.on("warning", (h) => {
          console.warn("Torrent warning:", h);
        });
      });
    } catch (o) {
      console.error("Error in startDownload:", o), n && n.invokeMethodAsync("OnTorrentErrorCallback", o), a(o);
    }
  });
}
async function Ni(e, t, i) {
  const n = document.getElementById(`torrent-file-${e}`);
  if (!n || !n.files || n.files.length === 0) {
    const a = "No file selected";
    console.error(a), i && i.invokeMethodAsync("OnTorrentErrorCallback", a);
    return;
  }
  const s = n.files[0];
  return console.log("Starting download from file:", s.name), De(), z || (console.log("Client not initialized, setting up..."), await kt(e)), F && (console.log("Destroying existing torrent..."), F.destroy(), F = null), new Promise((a, o) => {
    try {
      const l = document.querySelector(t);
      if (!l)
        throw new Error(`Container element not found: ${t}`);
      l.innerHTML = wt();
      const c = l.querySelector(".loading-status"), u = l.querySelector(".progress-bar");
      c && ge(c), u && ge(u);
      const m = {
        announce: [
          "wss://tracker.openwebtorrent.com",
          "wss://tracker.webtorrent.dev",
          "wss://tracker.btorrent.xyz"
        ],
        maxWebConns: 8,
        strategy: "sequential"
      };
      z.add(s, m, (b) => {
        console.log("Torrent added from file, files:", b.files.length), F = b;
        const d = b.files.find((y) => {
          const w = y.name.toLowerCase();
          return w.endsWith(".mp4") || w.endsWith(".webm") || w.endsWith(".mkv") || w.endsWith(".avi") || w.endsWith(".mov") || w.endsWith(".wmv") || w.endsWith(".flv");
        });
        if (!d) {
          const y = "No video file found in torrent";
          console.error(y), i && i.invokeMethodAsync("OnTorrentErrorCallback", y), o(new Error(y));
          return;
        }
        console.log("Video file found:", d.name), i && i.invokeMethodAsync("OnTorrentReadyCallback");
        const h = vt();
        V = h, l.appendChild(h), d.getBlobURL((y, w) => {
          if (y) {
            console.error("Error getting blob URL:", y), i && i.invokeMethodAsync("OnTorrentErrorCallback", y.toString()), o(y);
            return;
          }
          if (!w) {
            const A = "No blob URL received";
            i && i.invokeMethodAsync("OnTorrentErrorCallback", A), o(new Error(A));
            return;
          }
          console.log("Got blob URL, setting up video..."), h.src = w, h.style.display = "block";
          const T = l.querySelector(".d-flex");
          T && T.remove(), h.addEventListener("loadedmetadata", () => {
            console.log("Video metadata loaded"), b.progress > 0.05 && h.play().catch((A) => {
              console.warn("Could not auto-start video:", A);
            });
          });
        }), b.on("download", () => {
          const y = Math.round(b.progress * 100);
          c && (c.textContent = `Loading: ${y}%`), u && (u.style.width = `${y}%`), i && i.invokeMethodAsync("OnTorrentProgressUpdate", y), b.progress > 0.05 && V && V.paused && V.play().catch((w) => {
            console.warn("Could not start video:", w);
          });
        }), b.on("done", () => {
          console.log("Download complete"), i && i.invokeMethodAsync("OnTorrentProgressUpdate", 100), a();
        }), b.on("error", (y) => {
          console.error("Torrent error:", y), i && i.invokeMethodAsync("OnTorrentErrorCallback", y.message), o(y);
        });
      });
    } catch (l) {
      console.error("Error in startDownloadFromFile:", l), i && i.invokeMethodAsync("OnTorrentErrorCallback", l), o(l);
    }
  });
}
function Ii() {
  console.log("Stopping download..."), De(), F && (F.destroy(), F = null), z && (z.destroy(), z = null), console.log("Download stopped, resources cleaned up");
}
function Oi(e, t, i, n, s, a, o, l, c, u, m, b, d, h, y, w, T, A, g, C, $, D) {
  const N = [];
  i && N.push("captions"), n && N.push("quality"), s && N.push("speed"), a && N.push("loop");
  const M = [];
  o && M.push("play-large"), l && M.push("restart"), c && M.push("rewind"), u && M.push("play"), m && M.push("fast-forward"), b && M.push("progress"), d && M.push("current-time"), h && M.push("duration"), y && M.push("mute"), w && M.push("volume"), T && M.push("captions"), A && M.push("settings"), g && M.push("pip"), C && M.push("airplay"), $ && M.push("download"), D && M.push("fullscreen");
  const x = new re("#" + e, {
    settings: N,
    controls: M,
    quality: {
      default: 576,
      options: [4320, 2880, 2160, 1440, 1080, 720, 576, 480, 360, 240, 200, 100, 50, 20]
    }
  });
  x.on("ended", async () => {
    await t.invokeMethodAsync("OnEnded");
  }), x.on("timeupdate", async () => {
    await t.invokeMethodAsync("OnTimeUpdate", x.currentTime, x.duration);
  }), x.on("play", async () => {
    await t.invokeMethodAsync("OnPlay");
  });
}
export {
  kt as initTorrentPlayer,
  $i as startDownload,
  Ni as startDownloadFromFile,
  Ii as stopDownload,
  Oi as videoInitialize
};
